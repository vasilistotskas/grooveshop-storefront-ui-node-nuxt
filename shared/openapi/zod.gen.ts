// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * * `subscribe` - subscribe
 * * `unsubscribe` - unsubscribe
 */
export const zActionEnum = z.enum(['subscribe', 'unsubscribe']).register(z.globalRegistry, {
    description: '* `subscribe` - subscribe\n* `unsubscribe` - unsubscribe'
});

export const zAddTrackingRequest = z.object({
    trackingNumber: z.string().min(1).max(100),
    shippingCarrier: z.string().min(1).max(50)
});

/**
 * Serializer for Attribute with translations.
 */
export const zAttribute = z.object({
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    valuesCount: z.int().readonly(),
    usageCount: z.int().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer for Attribute with translations.'
});

/**
 * Serializer for AttributeValue with translations.
 */
export const zAttributeValue = z.object({
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    attribute: z.int(),
    attributeName: z.string().register(z.globalRegistry, {
        description: 'Return translated attribute name.'
    }).readonly(),
    translations: z.object({
        el: z.optional(z.object({
            value: z.optional(z.string())
        })),
        en: z.optional(z.object({
            value: z.optional(z.string())
        })),
        de: z.optional(z.object({
            value: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    usageCount: z.int().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer for AttributeValue with translations.'
});

export const zBlankEnum = z.enum(['']);

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogAuthor = z.object({
    translations: z.object({
        el: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        en: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        de: z.optional(z.object({
            bio: z.optional(z.string())
        }))
    }),
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    user: z.int(),
    website: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    numberOfPosts: z.int().readonly(),
    totalLikesReceived: z.union([
        z.int(),
        z.literal(0)
    ])
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogAuthorWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        en: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        de: z.optional(z.object({
            bio: z.optional(z.string())
        }))
    }),
    user: z.int(),
    website: z.optional(z.url().max(200))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCategory = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    level: z.int().readonly(),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    postCount: z.int().register(z.globalRegistry, {
        description: 'Return post count from annotation if available, otherwise query.\n\nUses _post_count annotation from BlogCategoryManager.for_list().'
    }).readonly(),
    hasChildren: z.boolean().register(z.globalRegistry, {
        description: 'Return has_children from annotation if available, otherwise query.\n\nUses _has_children annotation from BlogCategoryManager.for_list().'
    }).readonly(),
    mainImagePath: z.string().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCategoryDetail = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    level: z.int().readonly(),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    postCount: z.int().register(z.globalRegistry, {
        description: 'Return post count from annotation if available, otherwise query.\n\nUses _post_count annotation from BlogCategoryManager.for_list().'
    }).readonly(),
    hasChildren: z.boolean().register(z.globalRegistry, {
        description: 'Return has_children from annotation if available, otherwise query.\n\nUses _has_children annotation from BlogCategoryManager.for_list().'
    }).readonly(),
    mainImagePath: z.string().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    children: z.array(zBlogCategory).readonly(),
    ancestors: z.array(zBlogCategory).readonly(),
    siblingsCount: z.int().readonly(),
    descendantsCount: z.int().readonly(),
    recursivePostCount: z.int().readonly(),
    categoryPath: z.string().readonly(),
    treeId: z.int().readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zBlogCategoryReorderItemRequest = z.object({
    id: z.int().register(z.globalRegistry, {
        description: 'Category ID'
    }),
    sortOrder: z.int().register(z.globalRegistry, {
        description: 'New sort order value'
    })
});

export const zBlogCategoryReorderRequestRequest = z.object({
    categories: z.array(zBlogCategoryReorderItemRequest).register(z.globalRegistry, {
        description: 'List of categories with new sort orders'
    })
});

export const zBlogCategoryReorderResponse = z.object({
    updatedCount: z.int().register(z.globalRegistry, {
        description: 'Number of categories updated'
    }),
    message: z.string().register(z.globalRegistry, {
        description: 'Success message'
    })
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCategoryWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    image: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zBlogCommentLikedCommentsRequestRequest = z.object({
    commentIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of comment IDs to check like status for'
    })
});

export const zBlogCommentLikedCommentsResponse = z.object({
    likedCommentIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of comment IDs that are liked by the current user'
    })
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCommentWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            content: z.optional(z.string())
        })),
        en: z.optional(z.object({
            content: z.optional(z.string())
        })),
        de: z.optional(z.object({
            content: z.optional(z.string())
        }))
    }),
    user: z.optional(z.int()),
    post: z.int(),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogPost = z.object({
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    likes: z.array(z.int()),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        }))
    }),
    author: z.int(),
    category: z.int(),
    tags: z.array(z.int()),
    featured: z.optional(z.boolean()),
    viewCount: z.int().readonly(),
    likesCount: z.int().register(z.globalRegistry, {
        description: 'Return likes count from annotation or query database.'
    }).readonly(),
    commentsCount: z.int().register(z.globalRegistry, {
        description: 'Return comments count from annotation or query database.'
    }).readonly(),
    tagsCount: z.int().register(z.globalRegistry, {
        description: 'Return tags count from annotation or query database.'
    }).readonly(),
    isPublished: z.optional(z.boolean()),
    publishedAt: z.union([
        z.iso.datetime({ offset: true }).readonly(),
        z.null()
    ]).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    mainImagePath: z.string().readonly(),
    readingTime: z.int().readonly(),
    contentPreview: z.string().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogPostDetailRequest = z.object({
    slug: z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        }))
    }),
    featured: z.optional(z.boolean()),
    isPublished: z.optional(z.boolean()),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zBlogPostLikedPostsRequestRequest = z.object({
    postIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of post IDs to check for likes'
    })
});

export const zBlogPostLikedPostsResponse = z.object({
    postIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of liked post IDs'
    })
});

export const zBlogPostMeiliSearchResult = z.object({
    id: z.int(),
    languageCode: z.string(),
    title: z.string(),
    subtitle: z.string(),
    body: z.string(),
    master: z.int(),
    slug: z.string(),
    mainImagePath: z.string(),
    matchesPosition: z.unknown(),
    rankingScore: z.union([
        z.number(),
        z.null()
    ]),
    formatted: z.unknown(),
    contentType: z.string()
});

export const zBlogPostMeiliSearchResponse = z.object({
    limit: z.int(),
    offset: z.int(),
    estimatedTotalHits: z.int(),
    results: z.array(zBlogPostMeiliSearchResult)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogPostWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        }))
    }),
    slug: z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    tags: z.optional(z.array(z.int())),
    author: z.int(),
    featured: z.optional(z.boolean()),
    isPublished: z.optional(z.boolean()),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogTag = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    postsCount: z.string().register(z.globalRegistry, {
        description: 'Number of blog posts using this tag'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogTagDetail = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    postsCount: z.string().register(z.globalRegistry, {
        description: 'Number of blog posts using this tag'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogTagWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zBulkSubscriptionRequest = z.object({
    topicIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of topic IDs to subscribe/unsubscribe'
    }),
    action: zActionEnum
});

export const zCancelOrderRequestRequest = z.object({
    reason: z.optional(z.string().max(500).register(z.globalRegistry, {
        description: 'Reason for canceling the order'
    })),
    refundPayment: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether to automatically refund the payment if the order is paid'
    })).default(true)
});

export const zCartItemCreateRequest = z.object({
    product: z.int(),
    quantity: z.optional(z.int().gte(0).lte(2147483647))
});

export const zCartItemUpdateRequest = z.object({
    quantity: z.optional(z.int().gte(0).lte(2147483647))
});

export const zCartWriteRequest = z.object({
    user: z.optional(z.union([
        z.int(),
        z.null()
    ]))
});

/**
 * * `MARKETING` - Marketing Campaigns
 * * `PRODUCT` - Product Updates
 * * `ACCOUNT` - Λογαριασμός Ανενεργός
 * * `SYSTEM` - System Notifications
 * * `NEWSLETTER` - Newsletter
 * * `PROMOTIONAL` - Promotional
 * * `OTHER` - Other
 */
export const zCategoryEnum = z.enum([
    'MARKETING',
    'PRODUCT',
    'ACCOUNT',
    'SYSTEM',
    'NEWSLETTER',
    'PROMOTIONAL',
    'OTHER'
]).register(z.globalRegistry, {
    description: '* `MARKETING` - Marketing Campaigns\n* `PRODUCT` - Product Updates\n* `ACCOUNT` - Λογαριασμός Ανενεργός\n* `SYSTEM` - System Notifications\n* `NEWSLETTER` - Newsletter\n* `PROMOTIONAL` - Promotional\n* `OTHER` - Other'
});

export const zContactWrite = z.object({
    id: z.int().readonly(),
    name: z.string().max(100),
    email: z.email().max(254),
    message: z.string(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zContactWriteRequest = z.object({
    name: z.string().min(1).max(100),
    email: z.email().min(1).max(254),
    message: z.string().min(1)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zCountry = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha2: z.string().max(2).regex(/^[A-Z]{2}$/),
    alpha3: z.string().max(3).regex(/^[A-Z]{3}$/),
    isoCc: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ])),
    phoneCode: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ])),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    mainImagePath: z.string().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zCountryDetail = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha2: z.string().max(2).regex(/^[A-Z]{2}$/),
    alpha3: z.string().max(3).regex(/^[A-Z]{3}$/),
    isoCc: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ])),
    phoneCode: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ])),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    mainImagePath: z.string().readonly(),
    regions: z.array(z.string()).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zCountryWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha2: z.string().min(1).max(2).regex(/^[A-Z]{2}$/),
    alpha3: z.string().min(1).max(3).regex(/^[A-Z]{3}$/),
    isoCc: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ])),
    phoneCode: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zCreateCheckoutSessionRequestRequest = z.object({
    successUrl: z.url().min(1),
    cancelUrl: z.url().min(1),
    customerEmail: z.optional(z.email().min(1)),
    customerId: z.optional(z.string().min(1)),
    description: z.optional(z.string().min(1).max(500))
});

export const zCreateCheckoutSessionResponse = z.object({
    sessionId: z.string(),
    checkoutUrl: z.url(),
    status: z.string(),
    amount: z.string(),
    currency: z.string(),
    provider: z.string()
});

export const zCreatePaymentIntentRequestRequest = z.object({
    paymentData: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Additional payment data required by the payment provider'
    }))
});

export const zCreatePaymentIntentResponse = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'Payment intent ID from the payment provider'
    }),
    status: z.string().register(z.globalRegistry, {
        description: 'Payment status'
    }),
    amount: z.string().register(z.globalRegistry, {
        description: 'Payment amount'
    }),
    currency: z.string().register(z.globalRegistry, {
        description: 'Payment currency'
    }),
    provider: z.string().register(z.globalRegistry, {
        description: 'Payment provider name'
    }),
    clientSecret: z.optional(z.string().register(z.globalRegistry, {
        description: 'Stripe PaymentIntent client secret for frontend confirmation'
    })),
    requiresAction: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether the payment requires additional action (3D Secure, etc.)'
    })).default(false),
    nextAction: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ]))
});

/**
 * Serializer for date range in analytics.
 */
export const zDateRange = z.object({
    start: z.string().register(z.globalRegistry, {
        description: 'Start date of the analytics range (ISO format or \'all\')'
    }),
    end: z.string().register(z.globalRegistry, {
        description: 'End date of the analytics range (ISO format or \'now\')'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for date range in analytics.'
});

export const zDetailRequest = z.object({
    detail: z.string().min(1)
});

/**
 * * `RECEIPT` - Receipt
 * * `INVOICE` - Invoice
 * * `PROFORMA` - Proforma Invoice
 * * `SHIPPING_LABEL` - Shipping Label
 * * `RETURN_LABEL` - Return Label
 * * `CREDIT_NOTE` - Credit Note
 */
export const zDocumentTypeEnum = z.enum([
    'RECEIPT',
    'INVOICE',
    'PROFORMA',
    'SHIPPING_LABEL',
    'RETURN_LABEL',
    'CREDIT_NOTE'
]).register(z.globalRegistry, {
    description: '* `RECEIPT` - Receipt\n* `INVOICE` - Invoice\n* `PROFORMA` - Proforma Invoice\n* `SHIPPING_LABEL` - Shipping Label\n* `RETURN_LABEL` - Return Label\n* `CREDIT_NOTE` - Credit Note'
});

export const zErrorResponse = z.object({
    detail: z.string(),
    error: z.optional(z.string())
});

/**
 * Serializer for individual facet stat (min/max values).
 */
export const zFacetStatsItem = z.object({
    min: z.number(),
    max: z.number()
}).register(z.globalRegistry, {
    description: 'Serializer for individual facet stat (min/max values).'
});

/**
 * Serializer for facet statistics (numeric facets).
 */
export const zFacetStats = z.object({
    finalPrice: z.optional(zFacetStatsItem),
    likesCount: z.optional(zFacetStatsItem),
    viewCount: z.optional(zFacetStatsItem)
}).register(z.globalRegistry, {
    description: 'Serializer for facet statistics (numeric facets).'
});

/**
 * Serializer for federation metadata from Meilisearch.
 */
export const zFederationMetadata = z.object({
    indexUid: z.string().register(z.globalRegistry, {
        description: 'Index UID where the result originated'
    }),
    queriesPosition: z.int().register(z.globalRegistry, {
        description: 'Position of the query in the multi_search request'
    }),
    weightedRankingScore: z.number().register(z.globalRegistry, {
        description: 'Ranking score after applying federation weight'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for federation metadata from Meilisearch.'
});

/**
 * Serializer for individual federated search result.
 *
 * This combines fields from both ProductTranslation and BlogPostTranslation
 * with federation metadata.
 */
export const zFederatedSearchResult = z.object({
    id: z.int(),
    languageCode: z.string(),
    contentType: z.string().register(z.globalRegistry, {
        description: 'Type of content: \'product\' or \'blog_post\''
    }),
    slug: z.optional(z.string()),
    mainImagePath: z.optional(z.string()),
    matchesPosition: z.unknown(),
    rankingScore: z.union([
        z.number(),
        z.null()
    ]),
    formatted: z.unknown(),
    name: z.optional(z.string()),
    description: z.optional(z.string()),
    finalPrice: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    price: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    discountPercent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    stock: z.optional(z.int()),
    likesCount: z.optional(z.int()),
    viewCount: z.optional(z.int()),
    reviewAverage: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    vatPercent: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    title: z.optional(z.string()),
    subtitle: z.optional(z.string()),
    body: z.optional(z.string()),
    master: z.optional(z.int()),
    Federation: zFederationMetadata
}).register(z.globalRegistry, {
    description: 'Serializer for individual federated search result.\n\nThis combines fields from both ProductTranslation and BlogPostTranslation\nwith federation metadata.'
});

/**
 * Serializer for federated search response.
 */
export const zFederatedSearchResponse = z.object({
    limit: z.int().register(z.globalRegistry, {
        description: 'Maximum number of results requested'
    }),
    offset: z.int().register(z.globalRegistry, {
        description: 'Number of results skipped'
    }),
    estimatedTotalHits: z.int().register(z.globalRegistry, {
        description: 'Estimated total number of matching documents across all indexes'
    }),
    results: z.array(zFederatedSearchResult).register(z.globalRegistry, {
        description: 'Unified search results from products and blog posts'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for federated search response.'
});

/**
 * * `BASEMENT` - Basement
 * * `GROUND_FLOOR` - Ground Floor
 * * `FIRST_FLOOR` - First Floor
 * * `SECOND_FLOOR` - Second Floor
 * * `THIRD_FLOOR` - Third Floor
 * * `FOURTH_FLOOR` - Fourth Floor
 * * `FIFTH_FLOOR` - Fifth Floor
 * * `SIXTH_FLOOR_PLUS` - Sixth Floor Plus
 */
export const zFloorEnum = z.enum([
    'BASEMENT',
    'GROUND_FLOOR',
    'FIRST_FLOOR',
    'SECOND_FLOOR',
    'THIRD_FLOOR',
    'FOURTH_FLOOR',
    'FIFTH_FLOOR',
    'SIXTH_FLOOR_PLUS'
]).register(z.globalRegistry, {
    description: '* `BASEMENT` - Basement\n* `GROUND_FLOOR` - Ground Floor\n* `FIRST_FLOOR` - First Floor\n* `SECOND_FLOOR` - Second Floor\n* `THIRD_FLOOR` - Third Floor\n* `FOURTH_FLOOR` - Fourth Floor\n* `FIFTH_FLOOR` - Fifth Floor\n* `SIXTH_FLOOR_PLUS` - Sixth Floor Plus'
});

export const zHealthCheckResponse = z.object({
    database: z.boolean(),
    redis: z.boolean(),
    celery: z.boolean()
});

/**
 * * `MAIN` - Main Image
 * * `BANNER` - Banner Image
 * * `ICON` - Icon Image
 * * `THUMBNAIL` - Thumbnail Image
 * * `GALLERY` - Gallery Image
 * * `BACKGROUND` - Background Image
 * * `HERO` - Hero Image
 * * `FEATURE` - Feature Image
 * * `PROMOTIONAL` - Promotional Image
 * * `SEASONAL` - Seasonal Image
 */
export const zImageTypeEnum = z.enum([
    'MAIN',
    'BANNER',
    'ICON',
    'THUMBNAIL',
    'GALLERY',
    'BACKGROUND',
    'HERO',
    'FEATURE',
    'PROMOTIONAL',
    'SEASONAL'
]).register(z.globalRegistry, {
    description: '* `MAIN` - Main Image\n* `BANNER` - Banner Image\n* `ICON` - Icon Image\n* `THUMBNAIL` - Thumbnail Image\n* `GALLERY` - Gallery Image\n* `BACKGROUND` - Background Image\n* `HERO` - Hero Image\n* `FEATURE` - Feature Image\n* `PROMOTIONAL` - Promotional Image\n* `SEASONAL` - Seasonal Image'
});

/**
 * * `ERROR` - Error
 * * `SUCCESS` - Success
 * * `INFO` - Info
 * * `WARNING` - Warning
 * * `DANGER` - Danger
 */
export const zKindEnum = z.enum([
    'ERROR',
    'SUCCESS',
    'INFO',
    'WARNING',
    'DANGER'
]).register(z.globalRegistry, {
    description: '* `ERROR` - Error\n* `SUCCESS` - Success\n* `INFO` - Info\n* `WARNING` - Warning\n* `DANGER` - Danger'
});

/**
 * * `HOME` - Αρχική
 * * `OFFICE` - Office
 * * `OTHER` - Other
 */
export const zLocationTypeEnum = z.enum([
    'HOME',
    'OFFICE',
    'OTHER'
]).register(z.globalRegistry, {
    description: '* `HOME` - Αρχική\n* `OFFICE` - Office\n* `OTHER` - Other'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zNotification = z.object({
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            message: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            message: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            message: z.optional(z.string())
        }))
    }),
    id: z.int().readonly(),
    link: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    kind: z.optional(zKindEnum),
    expiryDate: z.optional(z.union([
        z.iso.datetime({ offset: true }),
        z.null()
    ])),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zNotificationCountResponse = z.object({
    count: z.int().register(z.globalRegistry, {
        description: 'Number of unseen notifications'
    })
});

export const zNotificationIdsRequest = z.object({
    ids: z.array(z.int())
});

export const zNotificationSuccessResponse = z.object({
    success: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether the operation was successful'
    }))
});

export const zNotificationSuccessResponseRequest = z.object({
    success: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether the operation was successful'
    }))
});

export const zNotificationUser = z.object({
    id: z.int().readonly(),
    user: z.int(),
    notification: z.int(),
    seen: z.optional(z.boolean()),
    seenAt: z.optional(z.union([
        z.iso.datetime({ offset: true }),
        z.null()
    ])),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zNotificationUserActionRequest = z.object({
    notificationUserIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of notification user IDs to mark as seen/unseen'
    })
});

export const zNotificationUserWriteRequest = z.object({
    user: z.int(),
    notification: z.int(),
    seen: z.optional(z.boolean())
});

/**
 * Serializer for creating orders from cart (dual-flow payment architecture).
 *
 * This serializer supports two payment flows:
 * 1. Online payments (is_online_payment=True): Requires payment_intent_id
 * 2. Offline payments (is_online_payment=False): No payment_intent_id required
 *
 * The order is created from an existing cart identified via X-Cart-Id header.
 * Cart is NOT sent in request body - it's retrieved from the header using CartService.
 */
export const zOrderCreateFromCartRequest = z.object({
    payWayId: z.int().register(z.globalRegistry, {
        description: 'Payment method ID'
    }),
    paymentIntentId: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    firstName: z.string().min(1).max(150).register(z.globalRegistry, {
        description: 'Customer first name'
    }),
    lastName: z.string().min(1).max(150).register(z.globalRegistry, {
        description: 'Customer last name'
    }),
    email: z.email().min(1).register(z.globalRegistry, {
        description: 'Customer email address'
    }),
    street: z.string().min(1).max(255).register(z.globalRegistry, {
        description: 'Street name'
    }),
    streetNumber: z.optional(z.string().max(50).register(z.globalRegistry, {
        description: 'Street number'
    })),
    city: z.string().min(1).max(100).register(z.globalRegistry, {
        description: 'City name'
    }),
    zipcode: z.string().min(1).max(20).register(z.globalRegistry, {
        description: 'Postal/ZIP code'
    }),
    countryId: z.string().min(1).register(z.globalRegistry, {
        description: 'Country alpha-2 code (e.g., \'GR\', \'US\')'
    }),
    regionId: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    phone: z.string().min(1).register(z.globalRegistry, {
        description: 'Customer phone number'
    }),
    customerNotes: z.optional(z.string().max(500).register(z.globalRegistry, {
        description: 'Customer notes or special instructions'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer for creating orders from cart (dual-flow payment architecture).\n\nThis serializer supports two payment flows:\n1. Online payments (is_online_payment=True): Requires payment_intent_id\n2. Offline payments (is_online_payment=False): No payment_intent_id required\n\nThe order is created from an existing cart identified via X-Cart-Id header.\nCart is NOT sent in request body - it\'s retrieved from the header using CartService.'
});

export const zOrderItem = z.object({
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    order: z.int(),
    product: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000).readonly(),
    quantity: z.optional(z.int().gte(-2147483648).lte(2147483647)),
    isRefunded: z.boolean().readonly(),
    refundedQuantity: z.int().readonly(),
    netQuantity: z.int().readonly(),
    totalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly()
});

export const zOrderItemCreateRequest = z.object({
    product: z.int(),
    quantity: z.optional(z.int().gte(-2147483648).lte(2147483647)),
    notes: z.optional(z.string())
});

export const zOrderItemRefundRequest = z.object({
    quantity: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Quantity to refund. If not provided, refunds all.'
    })),
    reason: z.optional(z.string().max(255).register(z.globalRegistry, {
        description: 'Optional reason for the refund'
    }))
});

export const zOrderItemRefundResponse = z.object({
    detail: z.string(),
    refundedAmount: z.number().gt(-1000000000).lt(1000000000),
    item: zOrderItem
});

export const zOrderItemWriteRequest = z.object({
    order: z.int(),
    product: z.int(),
    quantity: z.optional(z.int().gte(-2147483648).lte(2147483647)),
    notes: z.optional(z.string())
});

/**
 * * `PENDING` - Pending
 * * `PROCESSING` - Processing
 * * `SHIPPED` - Shipped
 * * `DELIVERED` - Delivered
 * * `COMPLETED` - Completed
 * * `CANCELED` - Canceled
 * * `RETURNED` - Returned
 * * `REFUNDED` - Refunded
 */
export const zOrderStatus = z.enum([
    'PENDING',
    'PROCESSING',
    'SHIPPED',
    'DELIVERED',
    'COMPLETED',
    'CANCELED',
    'RETURNED',
    'REFUNDED'
]).register(z.globalRegistry, {
    description: '* `PENDING` - Pending\n* `PROCESSING` - Processing\n* `SHIPPED` - Shipped\n* `DELIVERED` - Delivered\n* `COMPLETED` - Completed\n* `CANCELED` - Canceled\n* `RETURNED` - Returned\n* `REFUNDED` - Refunded'
});

export const zOrderWriteRequest = z.object({
    user: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    country: z.optional(z.union([
        z.string().min(1),
        z.null()
    ])),
    region: z.optional(z.union([
        z.string().min(1),
        z.null()
    ])),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    street: z.string().min(1).max(255),
    streetNumber: z.string().min(1).max(255),
    payWay: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    status: z.optional(zOrderStatus),
    firstName: z.string().min(1).max(255),
    lastName: z.string().min(1).max(255),
    email: z.email().min(1).max(255),
    zipcode: z.string().min(1).max(255),
    place: z.optional(z.string().max(255)),
    city: z.string().min(1).max(255),
    phone: z.string().min(1),
    paidAmount: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    customerNotes: z.optional(z.string()),
    items: z.array(zOrderItemCreateRequest),
    documentType: z.optional(zDocumentTypeEnum),
    paymentId: z.optional(z.string().min(1)),
    paymentStatus: z.optional(z.string().min(1)),
    paymentMethod: z.optional(z.string().min(1)),
    trackingNumber: z.optional(z.string().max(255)),
    shippingCarrier: z.optional(z.string().max(255))
});

export const zPaginatedAttributeList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zAttribute)
});

export const zPaginatedAttributeValueList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zAttributeValue)
});

export const zPaginatedBlogAuthorList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogAuthor)
});

export const zPaginatedBlogCategoryList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogCategory)
});

export const zPaginatedBlogPostList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogPost)
});

export const zPaginatedBlogTagList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogTag)
});

export const zPaginatedCountryList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zCountry)
});

export const zPaginatedNotificationUserList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zNotificationUser)
});

export const zPaginatedOrderItemList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zOrderItem)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedBlogAuthorWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        en: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        de: z.optional(z.object({
            bio: z.optional(z.string())
        }))
    })),
    user: z.optional(z.int()),
    website: z.optional(z.url().max(200))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedBlogCategoryWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    })),
    slug: z.optional(z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/)),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    image: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedBlogCommentWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            content: z.optional(z.string())
        })),
        en: z.optional(z.object({
            content: z.optional(z.string())
        })),
        de: z.optional(z.object({
            content: z.optional(z.string())
        }))
    })),
    user: z.optional(z.int()),
    post: z.optional(z.int()),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedBlogPostWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        }))
    })),
    slug: z.optional(z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/)),
    category: z.optional(z.int()),
    tags: z.optional(z.array(z.int())),
    author: z.optional(z.int()),
    featured: z.optional(z.boolean()),
    isPublished: z.optional(z.boolean()),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedBlogTagWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    })),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPatchedCartItemUpdateRequest = z.object({
    quantity: z.optional(z.int().gte(0).lte(2147483647))
});

export const zPatchedCartWriteRequest = z.object({
    user: z.optional(z.union([
        z.int(),
        z.null()
    ]))
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedCountryWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    })),
    alpha2: z.optional(z.string().min(1).max(2).regex(/^[A-Z]{2}$/)),
    alpha3: z.optional(z.string().min(1).max(3).regex(/^[A-Z]{3}$/)),
    isoCc: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ])),
    phoneCode: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPatchedNotificationUserWriteRequest = z.object({
    user: z.optional(z.int()),
    notification: z.optional(z.int()),
    seen: z.optional(z.boolean())
});

export const zPatchedOrderItemWriteRequest = z.object({
    order: z.optional(z.int()),
    product: z.optional(z.int()),
    quantity: z.optional(z.int().gte(-2147483648).lte(2147483647)),
    notes: z.optional(z.string())
});

export const zPatchedOrderWriteRequest = z.object({
    user: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    country: z.optional(z.union([
        z.string().min(1),
        z.null()
    ])),
    region: z.optional(z.union([
        z.string().min(1),
        z.null()
    ])),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    street: z.optional(z.string().min(1).max(255)),
    streetNumber: z.optional(z.string().min(1).max(255)),
    payWay: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    status: z.optional(zOrderStatus),
    firstName: z.optional(z.string().min(1).max(255)),
    lastName: z.optional(z.string().min(1).max(255)),
    email: z.optional(z.email().min(1).max(255)),
    zipcode: z.optional(z.string().min(1).max(255)),
    place: z.optional(z.string().max(255)),
    city: z.optional(z.string().min(1).max(255)),
    phone: z.optional(z.string().min(1)),
    paidAmount: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    customerNotes: z.optional(z.string()),
    items: z.optional(z.array(zOrderItemCreateRequest)),
    documentType: z.optional(zDocumentTypeEnum),
    paymentId: z.optional(z.string().min(1)),
    paymentStatus: z.optional(z.string().min(1)),
    paymentMethod: z.optional(z.string().min(1)),
    trackingNumber: z.optional(z.string().max(255)),
    shippingCarrier: z.optional(z.string().max(255))
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedPayWayWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        }))
    })),
    active: z.optional(z.boolean()),
    cost: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    freeThreshold: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    icon: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    providerCode: z.optional(z.string().max(50).register(z.globalRegistry, {
        description: 'Code used to identify the payment provider in the system (e.g., \'stripe\', \'paypal\')'
    })),
    isOnlinePayment: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method is processed online'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method requires manual confirmation (e.g., bank transfer)'
    })),
    configuration: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Provider-specific configuration (API keys, webhooks, etc.)'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPatchedProductCategoryImageBulkUpdateRequest = z.object({
    imageIds: z.optional(z.array(z.int())),
    active: z.optional(z.boolean()),
    sortOrder: z.optional(z.int())
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedProductCategoryImageWriteRequest = z.object({
    category: z.optional(z.int()),
    image: z.optional(z.string()),
    imageType: z.optional(zImageTypeEnum),
    active: z.optional(z.boolean()),
    translations: z.optional(z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        }))
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedProductCategoryWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    })),
    slug: z.optional(z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/)),
    active: z.optional(z.boolean()),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPatchedProductFavouriteWriteRequest = z.object({
    product: z.optional(z.int())
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedProductImageWriteRequest = z.object({
    product: z.optional(z.int()),
    image: z.optional(z.string()),
    isMain: z.optional(z.boolean()),
    translations: z.optional(z.object({
        el: z.optional(z.object({
            title: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string())
        }))
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedProductWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    })),
    slug: z.optional(z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/)),
    category: z.optional(z.int()),
    price: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    vat: z.optional(z.int()),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedRegionWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    })),
    alpha: z.optional(z.string().min(1).max(10)),
    country: z.optional(z.string().min(1))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedSubscriptionTopicWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    })),
    slug: z.optional(z.string().min(1).max(50).regex(/^[-a-zA-Z0-9_]+$/).register(z.globalRegistry, {
        description: 'Unique identifier for the topic (e.g., \'weekly-newsletter\')'
    })),
    category: z.optional(zCategoryEnum),
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this topic is currently available for subscription'
    })),
    isDefault: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether new users are automatically subscribed to this topic'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether subscription to this topic requires email confirmation'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedTagWriteRequest = z.object({
    translations: z.optional(z.object({
        el: z.optional(z.object({
            label: z.optional(z.string())
        })),
        en: z.optional(z.object({
            label: z.optional(z.string())
        })),
        de: z.optional(z.object({
            label: z.optional(z.string())
        }))
    })),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPatchedTaggedItemWriteRequest = z.object({
    contentType: z.optional(z.int()),
    objectId: z.optional(z.int().gte(0).lte(2147483647))
});

export const zPatchedUserAddressWriteRequest = z.object({
    title: z.optional(z.string().min(1).max(255)),
    firstName: z.optional(z.string().min(1).max(255)),
    lastName: z.optional(z.string().min(1).max(255)),
    street: z.optional(z.string().min(1).max(255)),
    streetNumber: z.optional(z.string().min(1).max(255)),
    city: z.optional(z.string().min(1).max(255)),
    zipcode: z.optional(z.string().min(1).max(255)),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    phone: z.optional(z.string().min(1)),
    notes: z.optional(z.string().max(255)),
    isMain: z.optional(z.boolean()).default(false),
    user: z.optional(z.int()),
    country: z.optional(z.string().min(1)),
    region: z.optional(z.string().min(1))
});

export const zPatchedUserWriteRequest = z.object({
    email: z.optional(z.email().min(1).max(254)),
    firstName: z.optional(z.string().max(255)),
    lastName: z.optional(z.string().max(255)),
    username: z.optional(z.union([
        z.string().max(30).regex(/^[\w.@+#-]+$/),
        z.null()
    ])),
    image: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    phone: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    city: z.optional(z.string().max(255)),
    zipcode: z.optional(z.string().max(255)),
    address: z.optional(z.string().max(255)),
    place: z.optional(z.string().max(255)),
    country: z.optional(z.union([
        z.string().min(1),
        z.null()
    ])),
    region: z.optional(z.union([
        z.string().min(1),
        z.null()
    ])),
    birthDate: z.optional(z.union([
        z.iso.date(),
        z.null()
    ])),
    twitter: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    linkedin: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    facebook: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    instagram: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    website: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    youtube: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    github: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    bio: z.optional(z.string())
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPayWay = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        }))
    }),
    id: z.int().readonly(),
    active: z.optional(z.boolean()),
    cost: z.number().gt(-1000000000).lt(1000000000),
    freeThreshold: z.number().gt(-1000000000).lt(1000000000),
    icon: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    mainImagePath: z.string().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    iconFilename: z.string().readonly(),
    providerCode: z.optional(z.string().max(50).register(z.globalRegistry, {
        description: 'Code used to identify the payment provider in the system (e.g., \'stripe\', \'paypal\')'
    })),
    isOnlinePayment: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method is processed online'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method requires manual confirmation (e.g., bank transfer)'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedPayWayList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zPayWay)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPayWayDetail = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        }))
    }),
    id: z.int().readonly(),
    active: z.optional(z.boolean()),
    cost: z.number().gt(-1000000000).lt(1000000000),
    freeThreshold: z.number().gt(-1000000000).lt(1000000000),
    icon: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    mainImagePath: z.string().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    iconFilename: z.string().readonly(),
    providerCode: z.optional(z.string().max(50).register(z.globalRegistry, {
        description: 'Code used to identify the payment provider in the system (e.g., \'stripe\', \'paypal\')'
    })),
    isOnlinePayment: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method is processed online'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method requires manual confirmation (e.g., bank transfer)'
    })),
    configuration: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Provider-specific configuration (API keys, webhooks, etc.)'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPayWayWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    cost: z.number().gt(-1000000000).lt(1000000000),
    freeThreshold: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    icon: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    providerCode: z.optional(z.string().max(50).register(z.globalRegistry, {
        description: 'Code used to identify the payment provider in the system (e.g., \'stripe\', \'paypal\')'
    })),
    isOnlinePayment: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method is processed online'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method requires manual confirmation (e.g., bank transfer)'
    })),
    configuration: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Provider-specific configuration (API keys, webhooks, etc.)'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * * `PENDING` - Pending
 * * `PROCESSING` - Processing
 * * `COMPLETED` - Completed
 * * `FAILED` - Failed
 * * `REFUNDED` - Refunded
 * * `PARTIALLY_REFUNDED` - Partially Refunded
 * * `CANCELED` - Canceled
 */
export const zPaymentStatusEnum = z.enum([
    'PENDING',
    'PROCESSING',
    'COMPLETED',
    'FAILED',
    'REFUNDED',
    'PARTIALLY_REFUNDED',
    'CANCELED'
]).register(z.globalRegistry, {
    description: '* `PENDING` - Pending\n* `PROCESSING` - Processing\n* `COMPLETED` - Completed\n* `FAILED` - Failed\n* `REFUNDED` - Refunded\n* `PARTIALLY_REFUNDED` - Partially Refunded\n* `CANCELED` - Canceled'
});

/**
 * Serializer for search performance metrics.
 */
export const zPerformanceMetrics = z.object({
    avgProcessingTimeMs: z.number().register(z.globalRegistry, {
        description: 'Average search processing time in milliseconds'
    }),
    avgResultsCount: z.number().register(z.globalRegistry, {
        description: 'Average number of results returned per search'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for search performance metrics.'
});

/**
 * Serializer for ProductAttribute with nested attribute and value info.
 */
export const zProductAttribute = z.object({
    id: z.int().readonly(),
    attributeId: z.int().readonly(),
    attributeName: z.string().register(z.globalRegistry, {
        description: 'Return translated attribute name.'
    }).readonly(),
    attributeValueId: z.int(),
    value: z.string().register(z.globalRegistry, {
        description: 'Return translated attribute value.'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer for ProductAttribute with nested attribute and value info.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProduct = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000),
    vat: z.int(),
    viewCount: z.int().readonly(),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    active: z.optional(z.boolean()),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    discountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    priceSavePercent: z.number().readonly(),
    vatPercent: z.number().readonly(),
    vatValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    finalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    mainImagePath: z.string().readonly(),
    reviewAverage: z.number().register(z.globalRegistry, {
        description: 'Return the average review rating for this product.'
    }).readonly(),
    reviewCount: z.int().register(z.globalRegistry, {
        description: 'Return the number of reviews for this product.'
    }).readonly(),
    likesCount: z.int().register(z.globalRegistry, {
        description: 'Return the number of likes/favourites for this product.'
    }).readonly(),
    attributes: z.array(zProductAttribute).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zCartItem = z.object({
    id: z.int().readonly(),
    cartId: z.int().readonly(),
    product: zProduct,
    quantity: z.optional(z.int().gte(0).lte(2147483647)),
    weightInfo: z.object({
        unitWeight: z.number(),
        totalWeight: z.number(),
        weightUnit: z.string()
    }).register(z.globalRegistry, {
        description: 'Weight information for shipping calculations'
    }).readonly(),
    price: z.number().gt(-1000000000).lt(1000000000).readonly(),
    finalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    discountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    priceSavePercent: z.number().readonly(),
    discountPercent: z.number().readonly(),
    vatPercent: z.number().readonly(),
    vatValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalDiscountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zCart = z.object({
    id: z.int().readonly(),
    user: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    uuid: z.uuid().readonly(),
    items: z.array(zCartItem).readonly(),
    totalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalDiscountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalVatValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalItems: z.union([
        z.int(),
        z.literal(0)
    ]),
    totalItemsUnique: z.int().register(z.globalRegistry, {
        description: 'Return the number of unique items in the cart.\n\nUses annotated value if available (from optimized queryset),\notherwise queries the database.'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    lastActivity: z.iso.datetime({ offset: true }).readonly()
});

export const zCartDetail = z.object({
    id: z.int().readonly(),
    user: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    uuid: z.uuid().readonly(),
    items: z.array(zCartItem).readonly(),
    totalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalDiscountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalVatValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalItems: z.union([
        z.int(),
        z.literal(0)
    ]),
    totalItemsUnique: z.int().register(z.globalRegistry, {
        description: 'Return the number of unique items in the cart.\n\nUses annotated value if available (from optimized queryset),\notherwise queries the database.'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    lastActivity: z.iso.datetime({ offset: true }).readonly(),
    recommendations: z.array(zProduct).register(z.globalRegistry, {
        description: 'Product recommendations based on cart contents'
    }).readonly()
});

export const zCartItemDetail = z.object({
    id: z.int().readonly(),
    cartId: z.int().readonly(),
    product: zProduct,
    quantity: z.optional(z.int().gte(0).lte(2147483647)),
    weightInfo: z.object({
        unitWeight: z.number(),
        totalWeight: z.number(),
        weightUnit: z.string()
    }).register(z.globalRegistry, {
        description: 'Weight information for shipping calculations'
    }).readonly(),
    price: z.number().gt(-1000000000).lt(1000000000).readonly(),
    finalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    discountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    priceSavePercent: z.number().readonly(),
    discountPercent: z.number().readonly(),
    vatPercent: z.number().readonly(),
    vatValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalDiscountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    recommendations: z.array(zProduct).register(z.globalRegistry, {
        description: 'Related products that might interest the customer'
    }).readonly()
});

export const zOrderItemDetail = z.object({
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    order: z.int(),
    product: zProduct,
    price: z.number().gt(-1000000000).lt(1000000000).readonly(),
    quantity: z.optional(z.int().gte(-2147483648).lte(2147483647)),
    isRefunded: z.boolean().readonly(),
    refundedQuantity: z.int().readonly(),
    netQuantity: z.int().readonly(),
    totalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    originalQuantity: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    refundedAmount: z.number().gt(-1000000000).lt(1000000000).readonly(),
    netPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    notes: z.optional(z.string())
});

export const zOrder = z.object({
    id: z.int().readonly(),
    user: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    country: z.string(),
    region: z.string(),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    street: z.string().max(255),
    streetNumber: z.string().max(255),
    payWay: z.int(),
    status: z.optional(zOrderStatus),
    statusDisplay: z.string().readonly(),
    statusUpdatedAt: z.union([
        z.iso.datetime({ offset: true }).readonly(),
        z.null()
    ]).readonly(),
    firstName: z.string().max(255),
    lastName: z.string().max(255),
    email: z.email().max(255),
    zipcode: z.string().max(255),
    place: z.optional(z.string().max(255)),
    city: z.string().max(255),
    phone: z.string(),
    customerNotes: z.optional(z.string()),
    paidAmount: z.number().gt(-1000000000).lt(1000000000).readonly(),
    items: z.array(zOrderItemDetail),
    shippingPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    paymentMethodFee: z.number().gt(-1000000000).lt(1000000000).readonly(),
    documentType: z.optional(zDocumentTypeEnum),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    totalPriceItems: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalPriceExtra: z.number().gt(-1000000000).lt(1000000000).readonly(),
    fullAddress: z.string().readonly(),
    paymentId: z.optional(z.union([
        z.string().max(255),
        z.null()
    ])),
    paymentStatus: z.optional(z.union([
        zPaymentStatusEnum,
        zBlankEnum
    ])),
    paymentMethod: z.optional(z.string().max(50)),
    canBeCanceled: z.boolean().readonly(),
    isPaid: z.boolean().readonly()
});

export const zOrderDetail = z.object({
    id: z.int().readonly(),
    user: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    country: z.string(),
    region: z.string(),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    street: z.string().max(255),
    streetNumber: z.string().max(255),
    payWay: z.int(),
    status: z.optional(zOrderStatus),
    statusDisplay: z.string().readonly(),
    statusUpdatedAt: z.union([
        z.iso.datetime({ offset: true }).readonly(),
        z.null()
    ]).readonly(),
    firstName: z.string().max(255),
    lastName: z.string().max(255),
    email: z.email().max(255),
    zipcode: z.string().max(255),
    place: z.optional(z.string().max(255)),
    city: z.string().max(255),
    phone: z.string().readonly(),
    customerNotes: z.optional(z.string()),
    paidAmount: z.number().gt(-1000000000).lt(1000000000).readonly(),
    items: z.array(zOrderItemDetail),
    shippingPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    paymentMethodFee: z.number().gt(-1000000000).lt(1000000000).readonly(),
    documentType: z.optional(zDocumentTypeEnum),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    totalPriceItems: z.number().gt(-1000000000).lt(1000000000).readonly(),
    totalPriceExtra: z.number().gt(-1000000000).lt(1000000000).readonly(),
    fullAddress: z.string().readonly(),
    paymentId: z.optional(z.union([
        z.string().max(255),
        z.null()
    ])),
    paymentStatus: z.optional(z.union([
        zPaymentStatusEnum,
        zBlankEnum
    ])),
    paymentMethod: z.optional(z.string().max(50)),
    canBeCanceled: z.boolean().readonly(),
    isPaid: z.boolean().readonly(),
    orderTimeline: z.array(z.object({
        changeType: z.optional(z.string()),
        timestamp: z.optional(z.string()),
        description: z.optional(z.string()),
        user: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    })).register(z.globalRegistry, {
        description: 'Order status timeline and history'
    }).readonly(),
    pricingBreakdown: z.object({
        itemsSubtotal: z.optional(z.number()),
        shippingCost: z.optional(z.number()),
        paymentMethodFee: z.optional(z.number()),
        extrasTotal: z.optional(z.number()),
        grandTotal: z.optional(z.number()),
        currency: z.optional(z.string()),
        paidAmount: z.optional(z.number()),
        remainingAmount: z.optional(z.number())
    }).register(z.globalRegistry, {
        description: 'Detailed pricing breakdown'
    }).readonly(),
    trackingDetails: z.union([
        z.object({
            trackingNumber: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            shippingCarrier: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            hasTracking: z.optional(z.boolean()),
            estimatedDelivery: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            trackingUrl: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }).readonly(),
        z.null()
    ]).readonly(),
    trackingNumber: z.optional(z.string().max(255)),
    shippingCarrier: z.optional(z.string().max(255)),
    customerFullName: z.string().readonly(),
    isCompleted: z.boolean().readonly(),
    isCanceled: z.boolean().readonly()
});

export const zPaginatedCartItemList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zCartItem)
});

export const zPaginatedCartList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zCart)
});

export const zPaginatedOrderList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zOrder)
});

export const zPaginatedProductList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProduct)
});

/**
 * Serializer for ProductAttribute with nested attribute and value info.
 */
export const zProductAttributeRequest = z.object({
    attributeValueId: z.int()
}).register(z.globalRegistry, {
    description: 'Serializer for ProductAttribute with nested attribute and value info.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategory = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    active: z.optional(z.boolean()),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    level: z.int().readonly(),
    treeId: z.int().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    recursiveProductCount: z.int().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductCategoryList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductCategory)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryDetail = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    active: z.optional(z.boolean()),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    level: z.int().readonly(),
    treeId: z.int().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    recursiveProductCount: z.int().readonly(),
    children: z.array(zProductCategory).readonly(),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryImage = z.object({
    id: z.int().readonly(),
    category: z.int(),
    categoryName: z.string().readonly(),
    image: z.url(),
    imageType: z.optional(zImageTypeEnum),
    active: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        }))
    }),
    imagePath: z.string().readonly(),
    imageUrl: z.string().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductCategoryImageList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductCategoryImage)
});

export const zProductCategoryImageBulkResponse = z.object({
    success: z.boolean(),
    message: z.string(),
    updatedCount: z.int()
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryImageDetail = z.object({
    id: z.int().readonly(),
    category: z.int(),
    categoryName: z.string().readonly(),
    image: z.url(),
    imageType: z.optional(zImageTypeEnum),
    active: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        }))
    }),
    imagePath: z.string().readonly(),
    imageUrl: z.string().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryImageWriteRequest = z.object({
    category: z.int(),
    image: z.string(),
    imageType: z.optional(zImageTypeEnum),
    active: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/),
    active: z.optional(z.boolean()),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductDetail = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000),
    vat: z.int(),
    viewCount: z.int().readonly(),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    active: z.optional(z.boolean()),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    discountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    priceSavePercent: z.number().readonly(),
    vatPercent: z.number().readonly(),
    vatValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    finalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    mainImagePath: z.string().readonly(),
    reviewAverage: z.number().register(z.globalRegistry, {
        description: 'Return the average review rating for this product.'
    }).readonly(),
    reviewCount: z.int().register(z.globalRegistry, {
        description: 'Return the number of reviews for this product.'
    }).readonly(),
    likesCount: z.int().register(z.globalRegistry, {
        description: 'Return the number of likes/favourites for this product.'
    }).readonly(),
    attributes: z.array(zProductAttribute).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductDetailRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000),
    vat: z.int(),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    active: z.optional(z.boolean()),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductDetailResponse = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000),
    vat: z.int(),
    viewCount: z.int().readonly(),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    active: z.optional(z.boolean()),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    discountValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    priceSavePercent: z.number().readonly(),
    vatPercent: z.number().readonly(),
    vatValue: z.number().gt(-1000000000).lt(1000000000).readonly(),
    finalPrice: z.number().gt(-1000000000).lt(1000000000).readonly(),
    mainImagePath: z.string().readonly(),
    reviewAverage: z.number().register(z.globalRegistry, {
        description: 'Return the average review rating for this product.'
    }).readonly(),
    reviewCount: z.int().register(z.globalRegistry, {
        description: 'Return the number of reviews for this product.'
    }).readonly(),
    likesCount: z.int().register(z.globalRegistry, {
        description: 'Return the number of likes/favourites for this product.'
    }).readonly(),
    attributes: z.array(zProductAttribute).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zProductFavourite = z.object({
    id: z.int().readonly(),
    userId: z.int().readonly(),
    userUsername: z.string().readonly(),
    product: zProductDetail,
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zPaginatedProductFavouriteList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductFavourite)
});

export const zProductFavouriteByProductsRequestRequest = z.object({
    productIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of product IDs to check for favorites'
    })
});

export const zProductFavouriteDetail = z.object({
    id: z.int().readonly(),
    userId: z.int().readonly(),
    userUsername: z.string().readonly(),
    product: zProductDetail,
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    user: z.string().readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly()
});

export const zProductFavouriteWrite = z.object({
    id: z.int().readonly(),
    product: z.int()
});

export const zProductFavouriteWriteRequest = z.object({
    product: z.int()
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductImage = z.object({
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    product: z.int().readonly(),
    image: z.url(),
    imageUrl: z.string().readonly(),
    imageSizeKb: z.number().readonly(),
    altText: z.string().readonly(),
    isMain: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string())
        }))
    }),
    mainImagePath: z.string().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductImageList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductImage)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductImageDetail = z.object({
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    product: zProduct,
    image: z.url(),
    imageUrl: z.string().readonly(),
    imageSizeKb: z.number().readonly(),
    altText: z.string().readonly(),
    isMain: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string())
        }))
    }),
    mainImagePath: z.string().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    imageDimensions: z.object({
        width: z.optional(z.number()),
        height: z.optional(z.number()),
        aspectRatio: z.optional(z.number())
    }).readonly(),
    imageFormat: z.string().readonly(),
    usageContext: z.object({
        isMain: z.optional(z.boolean()),
        positionInGallery: z.optional(z.number()),
        totalProductImages: z.optional(z.number()),
        recommendedFor: z.optional(z.string())
    }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductImageWriteRequest = z.object({
    product: z.int(),
    image: z.string(),
    isMain: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zProductMeiliSearchResult = z.object({
    id: z.int(),
    languageCode: z.string(),
    name: z.string(),
    description: z.string(),
    master: z.int(),
    slug: z.string(),
    mainImagePath: z.string(),
    matchesPosition: z.unknown(),
    rankingScore: z.union([
        z.number(),
        z.null()
    ]),
    formatted: z.unknown(),
    contentType: z.string(),
    finalPrice: z.union([
        z.number(),
        z.null()
    ]),
    price: z.union([
        z.number(),
        z.null()
    ]),
    discountPercent: z.union([
        z.int(),
        z.null()
    ]),
    stock: z.int(),
    likesCount: z.int(),
    viewCount: z.int(),
    reviewAverage: z.union([
        z.number(),
        z.null()
    ]),
    vatPercent: z.union([
        z.number(),
        z.null()
    ])
});

export const zProductMeiliSearchResponse = z.object({
    limit: z.int(),
    offset: z.int(),
    estimatedTotalHits: z.int(),
    results: z.array(zProductMeiliSearchResult),
    facetDistribution: z.optional(z.record(z.string(), z.record(z.string(), z.int())).register(z.globalRegistry, {
        description: 'Facet distribution with counts per category/value'
    })),
    facetStats: z.optional(zFacetStats)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().min(1).max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000),
    vat: z.int(),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000)),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * * `1` - One
 * * `2` - Two
 * * `3` - Three
 * * `4` - Four
 * * `5` - Five
 * * `6` - Six
 * * `7` - Seven
 * * `8` - Eight
 * * `9` - Nine
 * * `10` - Ten
 */
export const zRateEnum = z.union([
    z.literal(1),
    z.literal(2),
    z.literal(3),
    z.literal(4),
    z.literal(5),
    z.literal(6),
    z.literal(7),
    z.literal(8),
    z.literal(9),
    z.literal(10)
]).register(z.globalRegistry, {
    description: '* `1` - One\n* `2` - Two\n* `3` - Three\n* `4` - Four\n* `5` - Five\n* `6` - Six\n* `7` - Seven\n* `8` - Eight\n* `9` - Nine\n* `10` - Ten'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zRegion = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha: z.string().max(10),
    country: z.string(),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedRegionList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zRegion)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zRegionDetail = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha: z.string().max(10),
    country: z.string(),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zRegionWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha: z.string().min(1).max(10),
    country: z.string().min(1)
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer for releasing stock reservations.
 */
export const zReleaseReservationsRequestRequest = z.object({
    reservationIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of reservation IDs to release'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for releasing stock reservations.'
});

/**
 * Serializer for release reservations response.
 */
export const zReleaseReservationsResponse = z.object({
    message: z.string().register(z.globalRegistry, {
        description: 'Success message'
    }),
    releasedCount: z.int().register(z.globalRegistry, {
        description: 'Number of reservations released'
    }),
    failedReleases: z.optional(z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'List of failed releases with error details'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer for release reservations response.'
});

/**
 * Serializer for reserve stock response.
 */
export const zReserveStockResponse = z.object({
    reservationIds: z.array(z.int()).register(z.globalRegistry, {
        description: 'List of created stock reservation IDs'
    }),
    message: z.string().register(z.globalRegistry, {
        description: 'Success message'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for reserve stock response.'
});

/**
 * * `NEW` - New
 * * `TRUE` - True
 * * `FALSE` - False
 */
export const zReviewStatus = z.enum([
    'NEW',
    'TRUE',
    'FALSE'
]).register(z.globalRegistry, {
    description: '* `NEW` - New\n* `TRUE` - True\n* `FALSE` - False'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPatchedProductReviewWriteRequest = z.object({
    product: z.optional(z.int()),
    rate: z.optional(zRateEnum),
    status: z.optional(zReviewStatus),
    isPublished: z.optional(z.boolean()),
    translations: z.optional(z.object({
        el: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        en: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        de: z.optional(z.object({
            comment: z.optional(z.string())
        }))
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductReviewWriteRequest = z.object({
    product: z.int(),
    rate: zRateEnum,
    status: z.optional(zReviewStatus),
    isPublished: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        en: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        de: z.optional(z.object({
            comment: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer for search volume metrics.
 */
export const zSearchVolume = z.object({
    total: z.int().register(z.globalRegistry, {
        description: 'Total number of searches in the date range'
    }),
    byContentType: z.record(z.string(), z.int()).register(z.globalRegistry, {
        description: 'Search volume breakdown by content type (product, blog_post, federated)'
    }),
    byLanguage: z.record(z.string(), z.int()).register(z.globalRegistry, {
        description: 'Search volume breakdown by language code'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for search volume metrics.'
});

export const zSetting = z.object({
    name: z.string(),
    value: z.string(),
    type: z.string()
});

export const zSettingDetail = z.object({
    name: z.string(),
    value: z.string()
});

/**
 * * `ACTIVE` - Active
 * * `PENDING` - Pending Confirmation
 * * `UNSUBSCRIBED` - Unsubscribed
 * * `BOUNCED` - Bounced
 */
export const zSubscriptionStatus = z.enum([
    'ACTIVE',
    'PENDING',
    'UNSUBSCRIBED',
    'BOUNCED'
]).register(z.globalRegistry, {
    description: '* `ACTIVE` - Active\n* `PENDING` - Pending Confirmation\n* `UNSUBSCRIBED` - Unsubscribed\n* `BOUNCED` - Bounced'
});

export const zPatchedUserSubscriptionWriteRequest = z.object({
    topic: z.optional(z.int()),
    status: z.optional(zSubscriptionStatus),
    metadata: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Additional subscription preferences or data'
    }))
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zSubscriptionTopic = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    slug: z.string().max(50).regex(/^[-a-zA-Z0-9_]+$/).register(z.globalRegistry, {
        description: 'Unique identifier for the topic (e.g., \'weekly-newsletter\')'
    }),
    category: z.optional(zCategoryEnum),
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this topic is currently available for subscription'
    })),
    isDefault: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether new users are automatically subscribed to this topic'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether subscription to this topic requires email confirmation'
    })),
    subscriberCount: z.int().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedSubscriptionTopicList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zSubscriptionTopic)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zSubscriptionTopicDetail = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    slug: z.string().max(50).regex(/^[-a-zA-Z0-9_]+$/).register(z.globalRegistry, {
        description: 'Unique identifier for the topic (e.g., \'weekly-newsletter\')'
    }),
    category: z.optional(zCategoryEnum),
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this topic is currently available for subscription'
    })),
    isDefault: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether new users are automatically subscribed to this topic'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether subscription to this topic requires email confirmation'
    })),
    subscriberCount: z.int().readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zSubscriptionTopicRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().min(1).max(50).regex(/^[-a-zA-Z0-9_]+$/).register(z.globalRegistry, {
        description: 'Unique identifier for the topic (e.g., \'weekly-newsletter\')'
    }),
    category: z.optional(zCategoryEnum),
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this topic is currently available for subscription'
    })),
    isDefault: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether new users are automatically subscribed to this topic'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether subscription to this topic requires email confirmation'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zSubscriptionTopicWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().min(1).max(50).regex(/^[-a-zA-Z0-9_]+$/).register(z.globalRegistry, {
        description: 'Unique identifier for the topic (e.g., \'weekly-newsletter\')'
    }),
    category: z.optional(zCategoryEnum),
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this topic is currently available for subscription'
    })),
    isDefault: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether new users are automatically subscribed to this topic'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether subscription to this topic requires email confirmation'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zTag = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            label: z.optional(z.string())
        })),
        en: z.optional(z.object({
            label: z.optional(z.string())
        })),
        de: z.optional(z.object({
            label: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    usageCount: z.string().register(z.globalRegistry, {
        description: 'Number of times this tag is used'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedTagList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zTag)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zTagDetail = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            label: z.optional(z.string())
        })),
        en: z.optional(z.object({
            label: z.optional(z.string())
        })),
        de: z.optional(z.object({
            label: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    sortOrder: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    usageCount: z.string().register(z.globalRegistry, {
        description: 'Number of times this tag is used'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    contentTypes: z.string().register(z.globalRegistry, {
        description: 'Content types this tag is used with'
    }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zTagWriteRequest = z.object({
    translations: z.object({
        el: z.optional(z.object({
            label: z.optional(z.string())
        })),
        en: z.optional(z.object({
            label: z.optional(z.string())
        })),
        de: z.optional(z.object({
            label: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zTaggedItem = z.object({
    id: z.int().readonly(),
    tag: zTag,
    contentType: z.int(),
    contentTypeName: z.string().register(z.globalRegistry, {
        description: 'Name of the content type'
    }).readonly(),
    objectId: z.int().gte(0).lte(2147483647),
    contentObject: z.object({
        id: z.optional(z.int()),
        name: z.optional(z.string()),
        description: z.optional(z.string()),
        price: z.optional(z.string()),
        active: z.optional(z.boolean())
    }).register(z.globalRegistry, {
        description: 'Serialized representation of the related content object'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zPaginatedTaggedItemList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zTaggedItem)
});

export const zTaggedItemDetail = z.object({
    id: z.int().readonly(),
    tag: zTagDetail,
    contentType: z.int(),
    contentTypeName: z.string().register(z.globalRegistry, {
        description: 'Name of the content type'
    }).readonly(),
    objectId: z.int().gte(0).lte(2147483647),
    contentObject: z.object({
        id: z.optional(z.int()),
        name: z.optional(z.string()),
        description: z.optional(z.string()),
        price: z.optional(z.string()),
        active: z.optional(z.boolean())
    }).register(z.globalRegistry, {
        description: 'Serialized representation of the related content object'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zTaggedItemWriteRequest = z.object({
    contentType: z.int(),
    objectId: z.int().gte(0).lte(2147483647)
});

/**
 * Serializer for top query analytics.
 */
export const zTopQuery = z.object({
    query: z.string().register(z.globalRegistry, {
        description: 'The search query text'
    }),
    count: z.int().register(z.globalRegistry, {
        description: 'Number of times this query was searched'
    }),
    avgResults: z.number().register(z.globalRegistry, {
        description: 'Average number of results returned for this query'
    }),
    clickThroughRate: z.number().register(z.globalRegistry, {
        description: 'Click-through rate (clicks / searches) for this query'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for top query analytics.'
});

export const zUnsubscribe = z.object({
    message: z.string(),
    topic: z.optional(z.string()),
    userEmail: z.optional(z.email()),
    topicSlug: z.optional(z.string()),
    error: z.optional(z.string())
});

export const zUpdateStatusRequest = z.object({
    status: zOrderStatus
});

export const zUserAddress = z.object({
    id: z.int().readonly(),
    title: z.string().max(255),
    firstName: z.string().max(255),
    lastName: z.string().max(255),
    street: z.string().max(255),
    streetNumber: z.string().max(255),
    city: z.string().max(255),
    zipcode: z.string().max(255),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    phone: z.string(),
    notes: z.optional(z.string().max(255)),
    isMain: z.optional(z.boolean()).default(false),
    user: z.int().readonly(),
    country: z.string(),
    region: z.string(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zPaginatedUserAddressList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zUserAddress)
});

export const zUserAddressDetail = z.object({
    id: z.int().readonly(),
    title: z.string().max(255),
    firstName: z.string().max(255),
    lastName: z.string().max(255),
    street: z.string().max(255),
    streetNumber: z.string().max(255),
    city: z.string().max(255),
    zipcode: z.string().max(255),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    phone: z.string(),
    notes: z.optional(z.string().max(255)),
    isMain: z.optional(z.boolean()).default(false),
    user: z.int().readonly(),
    country: z.string(),
    region: z.string(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zUserAddressWriteRequest = z.object({
    title: z.string().min(1).max(255),
    firstName: z.string().min(1).max(255),
    lastName: z.string().min(1).max(255),
    street: z.string().min(1).max(255),
    streetNumber: z.string().min(1).max(255),
    city: z.string().min(1).max(255),
    zipcode: z.string().min(1).max(255),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    phone: z.string().min(1),
    notes: z.optional(z.string().max(255)),
    isMain: z.optional(z.boolean()).default(false),
    user: z.int(),
    country: z.string().min(1),
    region: z.optional(z.string().min(1))
});

export const zUserDetails = z.object({
    pk: z.int().readonly(),
    email: z.email().max(254),
    firstName: z.optional(z.string().max(255)),
    lastName: z.optional(z.string().max(255)),
    id: z.int().readonly(),
    username: z.optional(z.union([
        z.string().max(30).regex(/^[\w.@+#-]+$/),
        z.null()
    ])),
    phone: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    city: z.optional(z.string().max(255)),
    zipcode: z.optional(z.string().max(255)),
    address: z.optional(z.string().max(255)),
    place: z.optional(z.string().max(255)),
    country: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    region: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    birthDate: z.optional(z.union([
        z.iso.date(),
        z.null()
    ])),
    twitter: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    linkedin: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    facebook: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    instagram: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    website: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    youtube: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    github: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    bio: z.optional(z.string()),
    isActive: z.boolean().readonly(),
    isStaff: z.boolean().readonly(),
    isSuperuser: z.boolean().register(z.globalRegistry, {
        description: 'Υποδηλώνει ότι ο συγκεκριμένος χρήστης έχει όλα τα δικαιώματα χωρίς να χρειάζεται να τα παραχωρήσετε ξεχωριστά.'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    mainImagePath: z.string().readonly()
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogAuthorDetail = z.object({
    translations: z.object({
        el: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        en: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        de: z.optional(z.object({
            bio: z.optional(z.string())
        }))
    }),
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    user: zUserDetails,
    website: z.union([
        z.string().max(200).readonly(),
        z.null()
    ]).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    numberOfPosts: z.int().readonly(),
    totalLikesReceived: z.union([
        z.int(),
        z.literal(0)
    ]),
    recentPosts: z.array(zBlogPost).readonly(),
    topPosts: z.array(zBlogPost).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogComment = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            content: z.optional(z.string())
        })),
        en: z.optional(z.object({
            content: z.optional(z.string())
        })),
        de: z.optional(z.object({
            content: z.optional(z.string())
        }))
    }),
    user: zUserDetails,
    contentPreview: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    isReply: z.boolean().register(z.globalRegistry, {
        description: 'Whether this comment is a reply to another comment'
    }).readonly(),
    parent: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    hasReplies: z.boolean().register(z.globalRegistry, {
        description: 'Whether this comment has approved replies'
    }).readonly(),
    approved: z.boolean().readonly(),
    isEdited: z.boolean().register(z.globalRegistry, {
        description: 'Whether this comment has been edited'
    }).readonly(),
    likesCount: z.int().readonly(),
    repliesCount: z.int().readonly(),
    userHasLiked: z.boolean().register(z.globalRegistry, {
        description: 'Whether the current user has liked this comment'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCommentDetail = z.object({
    id: z.int().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            content: z.optional(z.string())
        })),
        en: z.optional(z.object({
            content: z.optional(z.string())
        })),
        de: z.optional(z.object({
            content: z.optional(z.string())
        }))
    }),
    user: zUserDetails,
    contentPreview: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    isReply: z.boolean().register(z.globalRegistry, {
        description: 'Whether this comment is a reply to another comment'
    }).readonly(),
    parent: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    hasReplies: z.boolean().register(z.globalRegistry, {
        description: 'Whether this comment has approved replies'
    }).readonly(),
    approved: z.boolean().readonly(),
    isEdited: z.boolean().register(z.globalRegistry, {
        description: 'Whether this comment has been edited'
    }).readonly(),
    likesCount: z.int().readonly(),
    repliesCount: z.int().readonly(),
    userHasLiked: z.boolean().register(z.globalRegistry, {
        description: 'Whether the current user has liked this comment'
    }).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly(),
    post: zBlogPost,
    parentComment: z.union([
        z.object({
            id: z.int(),
            contentPreview: z.string(),
            user: zUserDetails,
            createdAt: z.iso.datetime({ offset: true })
        }).readonly(),
        z.null()
    ]).readonly(),
    childrenComments: z.array(zBlogComment).register(z.globalRegistry, {
        description: 'Direct approved child comments (replies)'
    }).readonly(),
    ancestorsPath: z.array(z.object({
        id: z.int(),
        contentPreview: z.string(),
        user: zUserDetails
    })).register(z.globalRegistry, {
        description: 'Path from root comment to this comment'
    }).readonly(),
    treePosition: z.object({
        level: z.int(),
        treeId: z.int(),
        approvedDescendantsCount: z.int(),
        siblingsCount: z.int()
    }).register(z.globalRegistry, {
        description: 'Position information in the comment tree'
    }).readonly()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogPostDetail = z.object({
    id: z.int().readonly(),
    uuid: z.uuid().readonly(),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    likes: z.array(z.int()).readonly(),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        }))
    }),
    author: zBlogAuthorDetail,
    category: zBlogCategoryDetail,
    tags: z.array(zBlogTagDetail).readonly(),
    featured: z.optional(z.boolean()),
    viewCount: z.int().readonly(),
    likesCount: z.int().register(z.globalRegistry, {
        description: 'Return likes count from annotation or query database.'
    }).readonly(),
    commentsCount: z.int().register(z.globalRegistry, {
        description: 'Return comments count from annotation or query database.'
    }).readonly(),
    tagsCount: z.int().register(z.globalRegistry, {
        description: 'Return tags count from annotation or query database.'
    }).readonly(),
    isPublished: z.optional(z.boolean()),
    publishedAt: z.union([
        z.iso.datetime({ offset: true }).readonly(),
        z.null()
    ]).readonly(),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    mainImagePath: z.string().readonly(),
    readingTime: z.int().readonly(),
    contentPreview: z.string().readonly(),
    userHasLiked: z.boolean().readonly(),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zNotificationUserDetail = z.object({
    id: z.int().readonly(),
    user: zUserDetails,
    notification: zNotification,
    seen: z.optional(z.boolean()),
    seenAt: z.optional(z.union([
        z.iso.datetime({ offset: true }),
        z.null()
    ])),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    uuid: z.uuid().readonly()
});

export const zPaginatedBlogCommentList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogComment)
});

export const zPaginatedUserDetailsList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zUserDetails)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductReview = z.object({
    id: z.int().readonly(),
    product: zProduct,
    user: zUserDetails,
    rate: zRateEnum,
    status: z.optional(zReviewStatus),
    isPublished: z.optional(z.boolean()),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    publishedAt: z.union([
        z.iso.datetime({ offset: true }).readonly(),
        z.null()
    ]).readonly(),
    uuid: z.uuid().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        en: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        de: z.optional(z.object({
            comment: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductReviewList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductReview)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductReviewDetail = z.object({
    id: z.int().readonly(),
    product: zProduct,
    user: zUserDetails,
    rate: zRateEnum,
    status: z.optional(zReviewStatus),
    isPublished: z.optional(z.boolean()),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    publishedAt: z.union([
        z.iso.datetime({ offset: true }).readonly(),
        z.null()
    ]).readonly(),
    uuid: z.uuid().readonly(),
    translations: z.object({
        el: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        en: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        de: z.optional(z.object({
            comment: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zUserSubscription = z.object({
    id: z.int().readonly(),
    user: z.int().readonly(),
    topic: z.int(),
    topicDetails: zSubscriptionTopic,
    status: z.optional(zSubscriptionStatus),
    subscribedAt: z.iso.datetime({ offset: true }).readonly(),
    unsubscribedAt: z.union([
        z.iso.datetime({ offset: true }).readonly(),
        z.null()
    ]).readonly(),
    metadata: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Additional subscription preferences or data'
    })),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly()
});

export const zPaginatedUserSubscriptionList = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zUserSubscription)
});

export const zUserSubscriptionDetail = z.object({
    id: z.int().readonly(),
    user: z.int().readonly(),
    topic: z.int(),
    topicDetails: zSubscriptionTopic,
    status: z.optional(zSubscriptionStatus),
    subscribedAt: z.iso.datetime({ offset: true }).readonly(),
    unsubscribedAt: z.union([
        z.iso.datetime({ offset: true }).readonly(),
        z.null()
    ]).readonly(),
    metadata: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Additional subscription preferences or data'
    })),
    createdAt: z.iso.datetime({ offset: true }).readonly(),
    updatedAt: z.iso.datetime({ offset: true }).readonly(),
    confirmationToken: z.string().register(z.globalRegistry, {
        description: 'Token for email confirmation if required'
    }).readonly()
});

export const zUserSubscriptionDetailRequest = z.object({
    topic: z.int(),
    status: z.optional(zSubscriptionStatus),
    metadata: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Additional subscription preferences or data'
    }))
});

export const zUserSubscriptionRequest = z.object({
    topic: z.int(),
    status: z.optional(zSubscriptionStatus),
    metadata: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Additional subscription preferences or data'
    }))
});

export const zUserSubscriptionWriteRequest = z.object({
    topic: z.int(),
    status: z.optional(zSubscriptionStatus),
    metadata: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Additional subscription preferences or data'
    }))
});

export const zUserWriteRequest = z.object({
    email: z.email().min(1).max(254),
    firstName: z.optional(z.string().max(255)),
    lastName: z.optional(z.string().max(255)),
    username: z.optional(z.union([
        z.string().max(30).regex(/^[\w.@+#-]+$/),
        z.null()
    ])),
    image: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    phone: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    city: z.optional(z.string().max(255)),
    zipcode: z.optional(z.string().max(255)),
    address: z.optional(z.string().max(255)),
    place: z.optional(z.string().max(255)),
    country: z.optional(z.union([
        z.string().min(1),
        z.null()
    ])),
    region: z.optional(z.union([
        z.string().min(1),
        z.null()
    ])),
    birthDate: z.optional(z.union([
        z.iso.date(),
        z.null()
    ])),
    twitter: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    linkedin: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    facebook: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    instagram: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    website: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    youtube: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    github: z.optional(z.union([
        z.url().max(200),
        z.null()
    ])),
    bio: z.optional(z.string())
});

export const zUsernameUpdateRequest = z.object({
    username: z.string().min(1).max(150).register(z.globalRegistry, {
        description: 'New username'
    })
});

export const zUsernameUpdateResponse = z.object({
    detail: z.string().register(z.globalRegistry, {
        description: 'Success message for username update'
    })
});

/**
 * Serializer for zero-result query analytics.
 */
export const zZeroResultQuery = z.object({
    query: z.string().register(z.globalRegistry, {
        description: 'The search query text that returned no results'
    }),
    count: z.int().register(z.globalRegistry, {
        description: 'Number of times this query returned zero results'
    }),
    languageCode: z.string().register(z.globalRegistry, {
        description: 'Language code for the query'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for zero-result query analytics.'
});

/**
 * Serializer for search analytics response.
 */
export const zSearchAnalyticsResponse = z.object({
    dateRange: zDateRange,
    topQueries: z.array(zTopQuery).register(z.globalRegistry, {
        description: 'Top 20 queries by frequency with CTR metrics'
    }),
    zeroResultQueries: z.array(zZeroResultQuery).register(z.globalRegistry, {
        description: 'Queries that returned zero results'
    }),
    searchVolume: zSearchVolume,
    performance: zPerformanceMetrics,
    clickThroughRate: z.number().register(z.globalRegistry, {
        description: 'Overall click-through rate (total clicks / total searches)'
    })
}).register(z.globalRegistry, {
    description: 'Serializer for search analytics response.'
});

/**
 * Serializer for Attribute with translations.
 */
export const zAttributeWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer for Attribute with translations.'
});

/**
 * Serializer for AttributeValue with translations.
 */
export const zAttributeValueWritable = z.object({
    attribute: z.int(),
    translations: z.object({
        el: z.optional(z.object({
            value: z.optional(z.string())
        })),
        en: z.optional(z.object({
            value: z.optional(z.string())
        })),
        de: z.optional(z.object({
            value: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer for AttributeValue with translations.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogAuthorWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        en: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        de: z.optional(z.object({
            bio: z.optional(z.string())
        }))
    }),
    user: z.int()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogAuthorDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        en: z.optional(z.object({
            bio: z.optional(z.string())
        })),
        de: z.optional(z.object({
            bio: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCategoryWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCategoryDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCommentWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            content: z.optional(z.string())
        })),
        en: z.optional(z.object({
            content: z.optional(z.string())
        })),
        de: z.optional(z.object({
            content: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogCommentDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            content: z.optional(z.string())
        })),
        en: z.optional(z.object({
            content: z.optional(z.string())
        })),
        de: z.optional(z.object({
            content: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogPostWritable = z.object({
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    likes: z.array(z.int()),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        }))
    }),
    author: z.int(),
    category: z.int(),
    tags: z.array(z.int()),
    featured: z.optional(z.boolean()),
    isPublished: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogPostDetailWritable = z.object({
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            subtitle: z.optional(z.string()),
            body: z.optional(z.string())
        }))
    }),
    featured: z.optional(z.boolean()),
    isPublished: z.optional(z.boolean()),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogTagWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zBlogTagDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zCartWritable = z.object({
    user: z.optional(z.union([
        z.int(),
        z.null()
    ]))
});

export const zCartDetailWritable = z.object({
    user: z.optional(z.union([
        z.int(),
        z.null()
    ]))
});

export const zCartItemWritable = z.object({
    quantity: z.optional(z.int().gte(0).lte(2147483647))
});

export const zCartItemDetailWritable = z.object({
    quantity: z.optional(z.int().gte(0).lte(2147483647))
});

export const zContactWriteWritable = z.object({
    name: z.string().max(100),
    email: z.email().max(254),
    message: z.string()
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zCountryWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha2: z.string().max(2).regex(/^[A-Z]{2}$/),
    alpha3: z.string().max(3).regex(/^[A-Z]{3}$/),
    isoCc: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ])),
    phoneCode: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zCountryDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha2: z.string().max(2).regex(/^[A-Z]{2}$/),
    alpha3: z.string().max(3).regex(/^[A-Z]{3}$/),
    isoCc: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ])),
    phoneCode: z.optional(z.union([
        z.int().gte(0).lte(32767),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zNotificationWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            message: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            message: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            message: z.optional(z.string())
        }))
    }),
    kind: z.optional(zKindEnum),
    expiryDate: z.optional(z.union([
        z.iso.datetime({ offset: true }),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zNotificationUserWritable = z.object({
    user: z.int(),
    notification: z.int(),
    seen: z.optional(z.boolean()),
    seenAt: z.optional(z.union([
        z.iso.datetime({ offset: true }),
        z.null()
    ]))
});

export const zNotificationUserDetailWritable = z.object({
    seen: z.optional(z.boolean()),
    seenAt: z.optional(z.union([
        z.iso.datetime({ offset: true }),
        z.null()
    ]))
});

export const zOrderItemWritable = z.object({
    order: z.int(),
    product: z.int(),
    quantity: z.optional(z.int().gte(-2147483648).lte(2147483647))
});

export const zOrderItemDetailWritable = z.object({
    order: z.int(),
    quantity: z.optional(z.int().gte(-2147483648).lte(2147483647)),
    notes: z.optional(z.string())
});

export const zOrderWritable = z.object({
    user: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    country: z.string(),
    region: z.string(),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    street: z.string().max(255),
    streetNumber: z.string().max(255),
    payWay: z.int(),
    status: z.optional(zOrderStatus),
    firstName: z.string().max(255),
    lastName: z.string().max(255),
    email: z.email().max(255),
    zipcode: z.string().max(255),
    place: z.optional(z.string().max(255)),
    city: z.string().max(255),
    phone: z.string(),
    customerNotes: z.optional(z.string()),
    items: z.array(zOrderItemDetailWritable),
    documentType: z.optional(zDocumentTypeEnum),
    paymentId: z.optional(z.union([
        z.string().max(255),
        z.null()
    ])),
    paymentStatus: z.optional(z.union([
        zPaymentStatusEnum,
        zBlankEnum
    ])),
    paymentMethod: z.optional(z.string().max(50))
});

export const zOrderDetailWritable = z.object({
    user: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    country: z.string(),
    region: z.string(),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    street: z.string().max(255),
    streetNumber: z.string().max(255),
    payWay: z.int(),
    status: z.optional(zOrderStatus),
    firstName: z.string().max(255),
    lastName: z.string().max(255),
    email: z.email().max(255),
    zipcode: z.string().max(255),
    place: z.optional(z.string().max(255)),
    city: z.string().max(255),
    customerNotes: z.optional(z.string()),
    items: z.array(zOrderItemDetailWritable),
    documentType: z.optional(zDocumentTypeEnum),
    paymentId: z.optional(z.union([
        z.string().max(255),
        z.null()
    ])),
    paymentStatus: z.optional(z.union([
        zPaymentStatusEnum,
        zBlankEnum
    ])),
    paymentMethod: z.optional(z.string().max(50)),
    trackingNumber: z.optional(z.string().max(255)),
    shippingCarrier: z.optional(z.string().max(255))
});

export const zOrderItemRefundResponseWritable = z.object({
    detail: z.string(),
    refundedAmount: z.number().gt(-1000000000).lt(1000000000),
    item: zOrderItemWritable
});

export const zPaginatedAttributeListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zAttributeWritable)
});

export const zPaginatedAttributeValueListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zAttributeValueWritable)
});

export const zPaginatedBlogAuthorListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogAuthorWritable)
});

export const zPaginatedBlogCategoryListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogCategoryWritable)
});

export const zPaginatedBlogCommentListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogCommentWritable)
});

export const zPaginatedBlogPostListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogPostWritable)
});

export const zPaginatedBlogTagListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zBlogTagWritable)
});

export const zPaginatedCartItemListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zCartItemWritable)
});

export const zPaginatedCartListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zCartWritable)
});

export const zPaginatedCountryListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zCountryWritable)
});

export const zPaginatedNotificationUserListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zNotificationUserWritable)
});

export const zPaginatedOrderItemListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zOrderItemWritable)
});

export const zPaginatedOrderListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zOrderWritable)
});

export const zPatchedTaggedItemWriteRequestWritable = z.object({
    tagId: z.optional(z.int().register(z.globalRegistry, {
        description: 'ID of the tag to assign'
    })),
    contentType: z.optional(z.int()),
    objectId: z.optional(z.int().gte(0).lte(2147483647))
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPayWayWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    cost: z.number().gt(-1000000000).lt(1000000000),
    freeThreshold: z.number().gt(-1000000000).lt(1000000000),
    icon: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    providerCode: z.optional(z.string().max(50).register(z.globalRegistry, {
        description: 'Code used to identify the payment provider in the system (e.g., \'stripe\', \'paypal\')'
    })),
    isOnlinePayment: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method is processed online'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method requires manual confirmation (e.g., bank transfer)'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedPayWayListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zPayWayWritable)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zPayWayDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string()),
            instructions: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean()),
    cost: z.number().gt(-1000000000).lt(1000000000),
    freeThreshold: z.number().gt(-1000000000).lt(1000000000),
    icon: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    providerCode: z.optional(z.string().max(50).register(z.globalRegistry, {
        description: 'Code used to identify the payment provider in the system (e.g., \'stripe\', \'paypal\')'
    })),
    isOnlinePayment: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method is processed online'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this payment method requires manual confirmation (e.g., bank transfer)'
    })),
    configuration: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Provider-specific configuration (API keys, webhooks, etc.)'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000),
    vat: z.int(),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    active: z.optional(z.boolean()),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductWritable)
});

/**
 * Serializer for ProductAttribute with nested attribute and value info.
 */
export const zProductAttributeWritable = z.object({
    attributeValueId: z.int()
}).register(z.globalRegistry, {
    description: 'Serializer for ProductAttribute with nested attribute and value info.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    active: z.optional(z.boolean()),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductCategoryListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductCategoryWritable)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    active: z.optional(z.boolean()),
    parent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryImageWritable = z.object({
    category: z.int(),
    image: z.url(),
    imageType: z.optional(zImageTypeEnum),
    active: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductCategoryImageListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductCategoryImageWritable)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductCategoryImageDetailWritable = z.object({
    category: z.int(),
    image: z.url(),
    imageType: z.optional(zImageTypeEnum),
    active: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string()),
            altText: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000),
    vat: z.int(),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    active: z.optional(z.boolean()),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductDetailResponseWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(255).regex(/^[-a-zA-Z0-9_]+$/),
    category: z.int(),
    price: z.number().gt(-1000000000).lt(1000000000),
    vat: z.int(),
    stock: z.optional(z.int().gte(0).lte(2147483647)),
    active: z.optional(z.boolean()),
    weight: z.optional(z.union([
        z.object({
            unit: z.optional(z.string()),
            value: z.optional(z.number())
        }),
        z.null()
    ])),
    seoTitle: z.optional(z.string().max(70)),
    seoDescription: z.optional(z.string().max(300)),
    seoKeywords: z.optional(z.string().max(255)),
    discountPercent: z.optional(z.number().gt(-1000000000).lt(1000000000))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zProductFavouriteWritable = z.record(z.string(), z.unknown());

export const zPaginatedProductFavouriteListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductFavouriteWritable)
});

export const zProductFavouriteDetailWritable = z.record(z.string(), z.unknown());

export const zProductFavouriteWriteWritable = z.object({
    product: z.int()
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductImageWritable = z.object({
    image: z.url(),
    isMain: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductImageListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductImageWritable)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductImageDetailWritable = z.object({
    image: z.url(),
    isMain: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            title: z.optional(z.string())
        })),
        en: z.optional(z.object({
            title: z.optional(z.string())
        })),
        de: z.optional(z.object({
            title: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductReviewWritable = z.object({
    rate: zRateEnum,
    status: z.optional(zReviewStatus),
    isPublished: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        en: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        de: z.optional(z.object({
            comment: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedProductReviewListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zProductReviewWritable)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zProductReviewDetailWritable = z.object({
    rate: zRateEnum,
    status: z.optional(zReviewStatus),
    isPublished: z.optional(z.boolean()),
    translations: z.object({
        el: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        en: z.optional(z.object({
            comment: z.optional(z.string())
        })),
        de: z.optional(z.object({
            comment: z.optional(z.string())
        }))
    })
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zRegionWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha: z.string().max(10),
    country: z.string()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedRegionListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zRegionWritable)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zRegionDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string())
        }))
    }),
    alpha: z.string().max(10),
    country: z.string()
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zSubscriptionTopicWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(50).regex(/^[-a-zA-Z0-9_]+$/).register(z.globalRegistry, {
        description: 'Unique identifier for the topic (e.g., \'weekly-newsletter\')'
    }),
    category: z.optional(zCategoryEnum),
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this topic is currently available for subscription'
    })),
    isDefault: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether new users are automatically subscribed to this topic'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether subscription to this topic requires email confirmation'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedSubscriptionTopicListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zSubscriptionTopicWritable)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zSubscriptionTopicDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        en: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        })),
        de: z.optional(z.object({
            name: z.optional(z.string()),
            description: z.optional(z.string())
        }))
    }),
    slug: z.string().max(50).regex(/^[-a-zA-Z0-9_]+$/).register(z.globalRegistry, {
        description: 'Unique identifier for the topic (e.g., \'weekly-newsletter\')'
    }),
    category: z.optional(zCategoryEnum),
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this topic is currently available for subscription'
    })),
    isDefault: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether new users are automatically subscribed to this topic'
    })),
    requiresConfirmation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether subscription to this topic requires email confirmation'
    }))
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zTagWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            label: z.optional(z.string())
        })),
        en: z.optional(z.object({
            label: z.optional(z.string())
        })),
        de: z.optional(z.object({
            label: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zPaginatedTagListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zTagWritable)
});

/**
 * Serializer that saves :class:`TranslatedFieldsField` automatically.
 */
export const zTagDetailWritable = z.object({
    translations: z.object({
        el: z.optional(z.object({
            label: z.optional(z.string())
        })),
        en: z.optional(z.object({
            label: z.optional(z.string())
        })),
        de: z.optional(z.object({
            label: z.optional(z.string())
        }))
    }),
    active: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'Serializer that saves :class:`TranslatedFieldsField` automatically.'
});

export const zTaggedItemWritable = z.object({
    contentType: z.int(),
    objectId: z.int().gte(0).lte(2147483647)
});

export const zPaginatedTaggedItemListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zTaggedItemWritable)
});

export const zTaggedItemDetailWritable = z.object({
    contentType: z.int(),
    objectId: z.int().gte(0).lte(2147483647)
});

export const zTaggedItemWriteRequestWritable = z.object({
    tagId: z.int().register(z.globalRegistry, {
        description: 'ID of the tag to assign'
    }),
    contentType: z.int(),
    objectId: z.int().gte(0).lte(2147483647)
});

export const zUserAddressWritable = z.object({
    title: z.string().max(255),
    firstName: z.string().max(255),
    lastName: z.string().max(255),
    street: z.string().max(255),
    streetNumber: z.string().max(255),
    city: z.string().max(255),
    zipcode: z.string().max(255),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    phone: z.string(),
    notes: z.optional(z.string().max(255)),
    isMain: z.optional(z.boolean()).default(false),
    country: z.string(),
    region: z.string()
});

export const zPaginatedUserAddressListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zUserAddressWritable)
});

export const zUserAddressDetailWritable = z.object({
    title: z.string().max(255),
    firstName: z.string().max(255),
    lastName: z.string().max(255),
    street: z.string().max(255),
    streetNumber: z.string().max(255),
    city: z.string().max(255),
    zipcode: z.string().max(255),
    floor: z.optional(z.union([
        zFloorEnum,
        zBlankEnum
    ])),
    locationType: z.optional(z.union([
        zLocationTypeEnum,
        zBlankEnum
    ])),
    phone: z.string(),
    notes: z.optional(z.string().max(255)),
    isMain: z.optional(z.boolean()).default(false),
    country: z.string(),
    region: z.string()
});

export const zUserDetailsWritable = z.object({
    email: z.email().max(254),
    firstName: z.optional(z.string().max(255)),
    lastName: z.optional(z.string().max(255)),
    username: z.optional(z.union([
        z.string().max(30).regex(/^[\w.@+#-]+$/),
        z.null()
    ])),
    phone: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    city: z.optional(z.string().max(255)),
    zipcode: z.optional(z.string().max(255)),
    address: z.optional(z.string().max(255)),
    place: z.optional(z.string().max(255)),
    country: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    region: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    birthDate: z.optional(z.union([
        z.iso.date(),
        z.null()
    ])),
    bio: z.optional(z.string())
});

export const zPaginatedUserDetailsListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zUserDetailsWritable)
});

export const zUserSubscriptionWritable = z.object({
    topic: z.int(),
    status: z.optional(zSubscriptionStatus),
    metadata: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Additional subscription preferences or data'
    }))
});

export const zPaginatedUserSubscriptionListWritable = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.url(),
            z.null()
        ]))
    })),
    count: z.int(),
    totalPages: z.optional(z.int()),
    pageSize: z.optional(z.int()),
    pageTotalResults: z.optional(z.int()),
    page: z.optional(z.int()),
    results: z.array(zUserSubscriptionWritable)
});

export const zUserSubscriptionDetailWritable = z.object({
    topic: z.int(),
    status: z.optional(zSubscriptionStatus),
    metadata: z.optional(z.unknown().register(z.globalRegistry, {
        description: 'Additional subscription preferences or data'
    }))
});

export const zListBlogAuthorData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'user_FirstName',
            '-user_FirstName',
            'user_LastName',
            '-user_LastName',
            'user_Email',
            '-user_Email',
            'user_CreatedAt',
            '-user_CreatedAt',
            'website',
            '-website'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, user_FirstName, -user_FirstName, user_LastName, -user_LastName, user_Email, -user_Email, user_CreatedAt, -user_CreatedAt, website, -website'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListBlogAuthorResponse = zPaginatedBlogAuthorList;

export const zCreateBlogAuthorData = z.object({
    body: zBlogAuthorWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateBlogAuthorResponse = zBlogAuthorDetail;

export const zDestroyBlogAuthorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyBlogAuthorResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveBlogAuthorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveBlogAuthorResponse = zBlogAuthorDetail;

export const zPartialUpdateBlogAuthorData = z.object({
    body: z.optional(zPatchedBlogAuthorWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateBlogAuthorResponse = zBlogAuthorDetail;

export const zUpdateBlogAuthorData = z.object({
    body: zBlogAuthorWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateBlogAuthorResponse = zBlogAuthorDetail;

export const zGetBlogAuthorPostsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'user_FirstName',
            '-user_FirstName',
            'user_LastName',
            '-user_LastName',
            'user_Email',
            '-user_Email',
            'user_CreatedAt',
            '-user_CreatedAt',
            'website',
            '-website'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, user_FirstName, -user_FirstName, user_LastName, -user_LastName, user_Email, -user_Email, user_CreatedAt, -user_CreatedAt, website, -website'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetBlogAuthorPostsResponse = zPaginatedBlogPostList;

export const zListBlogCategoryData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'level',
            '-level',
            'lft',
            '-lft',
            'rght',
            '-rght',
            'treeId',
            '-treeId',
            'name',
            '-name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, level, -level, lft, -lft, rght, -rght, treeId, -treeId, name, -name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListBlogCategoryResponse = zPaginatedBlogCategoryList;

export const zCreateBlogCategoryData = z.object({
    body: zBlogCategoryWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateBlogCategoryResponse = zBlogCategoryDetail;

export const zDestroyBlogCategoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyBlogCategoryResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveBlogCategoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveBlogCategoryResponse = zBlogCategoryDetail;

export const zPartialUpdateBlogCategoryData = z.object({
    body: z.optional(zPatchedBlogCategoryWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateBlogCategoryResponse = zBlogCategoryDetail;

export const zUpdateBlogCategoryData = z.object({
    body: zBlogCategoryWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateBlogCategoryResponse = zBlogCategoryDetail;

export const zListBlogCategoryAncestorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'level',
            '-level',
            'lft',
            '-lft',
            'rght',
            '-rght',
            'treeId',
            '-treeId',
            'name',
            '-name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, level, -level, lft, -lft, rght, -rght, treeId, -treeId, name, -name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListBlogCategoryAncestorsResponse = zPaginatedBlogCategoryList;

export const zListBlogCategoryChildrenData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'level',
            '-level',
            'lft',
            '-lft',
            'rght',
            '-rght',
            'treeId',
            '-treeId',
            'name',
            '-name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, level, -level, lft, -lft, rght, -rght, treeId, -treeId, name, -name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListBlogCategoryChildrenResponse = zPaginatedBlogCategoryList;

export const zListBlogCategoryDescendantsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'level',
            '-level',
            'lft',
            '-lft',
            'rght',
            '-rght',
            'treeId',
            '-treeId',
            'name',
            '-name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, level, -level, lft, -lft, rght, -rght, treeId, -treeId, name, -name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListBlogCategoryDescendantsResponse = zPaginatedBlogCategoryList;

export const zListBlogCategoryPostsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'level',
            '-level',
            'lft',
            '-lft',
            'rght',
            '-rght',
            'treeId',
            '-treeId',
            'name',
            '-name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, level, -level, lft, -lft, rght, -rght, treeId, -treeId, name, -name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        recursive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListBlogCategoryPostsResponse = zPaginatedBlogPostList;

export const zListBlogCategorySiblingsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'level',
            '-level',
            'lft',
            '-lft',
            'rght',
            '-rght',
            'treeId',
            '-treeId',
            'name',
            '-name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, level, -level, lft, -lft, rght, -rght, treeId, -treeId, name, -name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListBlogCategorySiblingsResponse = zPaginatedBlogCategoryList;

export const zReorderBlogCategoriesData = z.object({
    body: zBlogCategoryReorderRequestRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zReorderBlogCategoriesResponse = zBlogCategoryReorderResponse;

export const zGetBlogCategoryTreeData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'level',
            '-level',
            'lft',
            '-lft',
            'rght',
            '-rght',
            'treeId',
            '-treeId',
            'name',
            '-name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, level, -level, lft, -lft, rght, -rght, treeId, -treeId, name, -name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetBlogCategoryTreeResponse = zPaginatedBlogCategoryList;

export const zListBlogCommentData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        ancestorOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        approved: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        content: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by comment content (case-insensitive)'
        })),
        contentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        descendantOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        hasContent: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasLikes: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasReplies: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isAnonymous: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isLeaf: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        level: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        likedBy: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxContentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxReplies: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minContentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minReplies: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        mostLiked: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        mostReplied: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'level',
            '-level',
            'lft',
            '-lft',
            'approved',
            '-approved'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, level, -level, lft, -lft, approved, -approved'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        parent: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parent_Isnull: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        post: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post category slug'
        })),
        post_IsPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        post_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post slug'
        })),
        post_Title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post title'
        })),
        rght: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rght_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rght_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        treeId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        user_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email'
        })),
        user_IsActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_IsStaff: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        uuid: z.optional(z.uuid())
    }))
});

export const zListBlogCommentResponse = zPaginatedBlogCommentList;

export const zCreateBlogCommentData = z.object({
    body: zBlogCommentWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateBlogCommentResponse = zBlogCommentDetail;

export const zDestroyBlogCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyBlogCommentResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveBlogCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveBlogCommentResponse = zBlogCommentDetail;

export const zPartialUpdateBlogCommentData = z.object({
    body: z.optional(zPatchedBlogCommentWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateBlogCommentResponse = zBlogCommentDetail;

export const zUpdateBlogCommentData = z.object({
    body: zBlogCommentWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateBlogCommentResponse = zBlogCommentDetail;

export const zGetBlogCommentPostData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zGetBlogCommentPostResponse = zBlogPostDetail;

export const zListBlogCommentRepliesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ancestorOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        approved: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        content: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by comment content (case-insensitive)'
        })),
        contentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        descendantOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        hasContent: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasLikes: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasReplies: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isAnonymous: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isLeaf: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        level: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        likedBy: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxContentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxReplies: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minContentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minReplies: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        mostLiked: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        mostReplied: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'level',
            '-level',
            'lft',
            '-lft',
            'approved',
            '-approved'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, level, -level, lft, -lft, approved, -approved'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parent: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parent_Isnull: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        post: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post category slug'
        })),
        post_IsPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        post_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post slug'
        })),
        post_Title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post title'
        })),
        rght: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rght_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rght_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        treeId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        user_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email'
        })),
        user_IsActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_IsStaff: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        uuid: z.optional(z.uuid())
    }))
});

export const zListBlogCommentRepliesResponse = zPaginatedBlogCommentList;

export const zGetBlogCommentThreadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ancestorOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        approved: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        content: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by comment content (case-insensitive)'
        })),
        contentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        descendantOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        hasContent: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasLikes: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasReplies: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isAnonymous: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isLeaf: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        level: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        likedBy: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxContentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxReplies: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minContentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minReplies: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        mostLiked: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        mostReplied: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'level',
            '-level',
            'lft',
            '-lft',
            'approved',
            '-approved'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, level, -level, lft, -lft, approved, -approved'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parent: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parent_Isnull: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        post: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post category slug'
        })),
        post_IsPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        post_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post slug'
        })),
        post_Title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post title'
        })),
        rght: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rght_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rght_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        treeId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        user_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email'
        })),
        user_IsActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_IsStaff: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        uuid: z.optional(z.uuid())
    }))
});

export const zGetBlogCommentThreadResponse = zPaginatedBlogCommentList;

export const zToggleBlogCommentLikeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zToggleBlogCommentLikeResponse = zBlogCommentDetail;

export const zCheckBlogCommentLikesData = z.object({
    body: zBlogCommentLikedCommentsRequestRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCheckBlogCommentLikesResponse = zBlogCommentLikedCommentsResponse;

export const zListMyBlogCommentsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        ancestorOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        approved: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        content: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by comment content (case-insensitive)'
        })),
        contentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        descendantOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        hasContent: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasLikes: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasReplies: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isAnonymous: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isLeaf: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        level: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        lft_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        likedBy: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxContentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxReplies: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minContentLength: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minReplies: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        mostLiked: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        mostReplied: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'level',
            '-level',
            'lft',
            '-lft',
            'approved',
            '-approved'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, level, -level, lft, -lft, approved, -approved'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parent: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parent_Isnull: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        post: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post category slug'
        })),
        post_IsPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        post_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post slug'
        })),
        post_Title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by blog post title'
        })),
        rght: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rght_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rght_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        treeId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        user_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email'
        })),
        user_IsActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_IsStaff: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        uuid: z.optional(z.uuid())
    }))
});

export const zListMyBlogCommentsResponse = zPaginatedBlogCommentList;

export const zListBlogPostData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        authorEmail: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by author email (case-insensitive)'
        })),
        authorName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by author full name (case-insensitive)'
        })),
        category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        categoryName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by category name (case-insensitive)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        currentlyPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        featured: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        minComments: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minTags: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minViewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'publishedAt',
            '-publishedAt',
            'viewCount',
            '-viewCount',
            'featured',
            '-featured'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, publishedAt, -publishedAt, viewCount, -viewCount, featured, -featured'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        publishedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published after this date'
        })),
        publishedAt_Date: z.optional(z.iso.date()),
        publishedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        publishedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        publishedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published before this date'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        slug: z.optional(z.string()),
        slug_Icontains: z.optional(z.string()),
        tagName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tag label (case-insensitive)'
        })),
        tags: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by title (case-insensitive)'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid()),
        viewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zListBlogPostResponse = zPaginatedBlogPostList;

export const zCreateBlogPostData = z.object({
    body: zBlogPostWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateBlogPostResponse = zBlogPostDetail;

export const zDestroyBlogPostData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyBlogPostResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveBlogPostData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveBlogPostResponse = zBlogPostDetail;

export const zPartialUpdateBlogPostData = z.object({
    body: z.optional(zPatchedBlogPostWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateBlogPostResponse = zBlogPostDetail;

export const zUpdateBlogPostData = z.object({
    body: zBlogPostWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateBlogPostResponse = zBlogPostDetail;

export const zListBlogPostCommentsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'publishedAt',
            '-publishedAt',
            'viewCount',
            '-viewCount',
            'featured',
            '-featured'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, publishedAt, -publishedAt, viewCount, -viewCount, featured, -featured'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parent: z.optional(z.string().register(z.globalRegistry, {
            description: 'Parent comment ID'
        })),
        parent_Isnull: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListBlogPostCommentsResponse = zPaginatedBlogCommentList;

export const zListBlogPostRelatedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zListBlogPostRelatedResponse = z.array(zBlogPost);

export const zToggleBlogPostLikeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zToggleBlogPostLikeResponse = zBlogPostDetail;

export const zIncrementBlogPostViewsData = z.object({
    body: zBlogPostDetailRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zIncrementBlogPostViewsResponse = zBlogPostDetail;

export const zListFeaturedBlogPostsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        authorEmail: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by author email (case-insensitive)'
        })),
        authorName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by author full name (case-insensitive)'
        })),
        category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        categoryName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by category name (case-insensitive)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        currentlyPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        featured: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        minComments: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minTags: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minViewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'publishedAt',
            '-publishedAt',
            'viewCount',
            '-viewCount',
            'featured',
            '-featured'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, publishedAt, -publishedAt, viewCount, -viewCount, featured, -featured'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        publishedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published after this date'
        })),
        publishedAt_Date: z.optional(z.iso.date()),
        publishedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        publishedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        publishedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published before this date'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        slug: z.optional(z.string()),
        slug_Icontains: z.optional(z.string()),
        tagName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tag label (case-insensitive)'
        })),
        tags: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by title (case-insensitive)'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid()),
        viewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zListFeaturedBlogPostsResponse = zPaginatedBlogPostList;

export const zCheckBlogPostLikesData = z.object({
    body: zBlogPostLikedPostsRequestRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCheckBlogPostLikesResponse = zBlogPostLikedPostsResponse;

export const zListPopularBlogPostsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        authorEmail: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by author email (case-insensitive)'
        })),
        authorName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by author full name (case-insensitive)'
        })),
        category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        categoryName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by category name (case-insensitive)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        currentlyPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        featured: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        minComments: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minTags: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minViewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'publishedAt',
            '-publishedAt',
            'viewCount',
            '-viewCount',
            'featured',
            '-featured'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, publishedAt, -publishedAt, viewCount, -viewCount, featured, -featured'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        publishedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published after this date'
        })),
        publishedAt_Date: z.optional(z.iso.date()),
        publishedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        publishedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        publishedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published before this date'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        slug: z.optional(z.string()),
        slug_Icontains: z.optional(z.string()),
        tagName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tag label (case-insensitive)'
        })),
        tags: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by title (case-insensitive)'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid()),
        viewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zListPopularBlogPostsResponse = zPaginatedBlogPostList;

export const zListTrendingBlogPostsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        authorEmail: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by author email (case-insensitive)'
        })),
        authorName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by author full name (case-insensitive)'
        })),
        category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        categoryName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by category name (case-insensitive)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        currentlyPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        days: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        featured: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        minComments: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minTags: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minViewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'publishedAt',
            '-publishedAt',
            'viewCount',
            '-viewCount',
            'featured',
            '-featured'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, publishedAt, -publishedAt, viewCount, -viewCount, featured, -featured'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        publishedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published after this date'
        })),
        publishedAt_Date: z.optional(z.iso.date()),
        publishedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        publishedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        publishedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published before this date'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        slug: z.optional(z.string()),
        slug_Icontains: z.optional(z.string()),
        tagName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tag label (case-insensitive)'
        })),
        tags: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by title (case-insensitive)'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid()),
        viewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zListTrendingBlogPostsResponse = zPaginatedBlogPostList;

export const zListBlogTagData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        hasLikedPosts: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasName: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasPosts: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        maxPosts: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minPosts: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minTotalLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        mostLiked: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        mostUsed: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tag name (partial match)'
        })),
        name_Exact: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact tag name'
        })),
        name_Startswith: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter tags with names starting with'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'active',
            '-active',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'name',
            '-name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, active, -active, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, name, -name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        post: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Author: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_Category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        post_IsPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        translations_Name: z.optional(z.string()),
        translations_Name_Icontains: z.optional(z.string()),
        translations_Name_Istartswith: z.optional(z.string()),
        unused: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListBlogTagResponse = zPaginatedBlogTagList;

export const zCreateBlogTagData = z.object({
    body: zBlogTagWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateBlogTagResponse = zBlogTagDetail;

export const zDestroyBlogTagData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyBlogTagResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveBlogTagData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveBlogTagResponse = zBlogTagDetail;

export const zPartialUpdateBlogTagData = z.object({
    body: z.optional(zPatchedBlogTagWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateBlogTagResponse = zBlogTagDetail;

export const zUpdateBlogTagData = z.object({
    body: zBlogTagWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateBlogTagResponse = zBlogTagDetail;

export const zDestroyCartData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

/**
 * No response body
 */
export const zDestroyCartResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveCartData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zRetrieveCartResponse = zCartDetail;

export const zPartialUpdateCartData = z.object({
    body: z.optional(zPatchedCartWriteRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zPartialUpdateCartResponse = zCartDetail;

export const zUpdateCartData = z.object({
    body: z.optional(zCartWriteRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zUpdateCartResponse = zCartDetail;

export const zCreateCartPaymentIntentData = z.object({
    body: z.optional(z.object({
        pay_way_id: z.int().register(z.globalRegistry, {
            description: 'Payment method ID (must be Stripe)'
        })
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zCreateCartPaymentIntentResponse = z.object({
    client_secret: z.optional(z.string().register(z.globalRegistry, {
        description: 'Stripe client secret for payment confirmation'
    })),
    payment_intent_id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Payment intent ID to include in order creation'
    }))
});

export const zListCartItemData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        cart: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        cart_IsGuest: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        cart_User: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        cart_User_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by cart user email (partial match)'
        })),
        cart_User_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by cart user name (first or last)'
        })),
        cart_Uuid: z.optional(z.uuid().register(z.globalRegistry, {
            description: 'Filter by cart UUID'
        })),
        cartLastActivityAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter by cart last activity after date'
        })),
        cartLastActivityBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter by cart last activity before date'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        inAbandonedCarts: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        inActiveCarts: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        maxDiscountPercent: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxPrice: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxQuantity: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        maxTotalPrice: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minDiscountPercent: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minPrice: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minQuantity: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        minTotalPrice: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'quantity',
            '-quantity',
            'cart_Id',
            '-cart_Id',
            'cart_LastActivity',
            '-cart_LastActivity',
            'product_Id',
            '-product_Id'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, quantity, -quantity, cart_Id, -cart_Id, cart_LastActivity, -cart_LastActivity, product_Id, -product_Id'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        product: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        product_Active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        product_Category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        product_Category_Slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by product category slug'
        })),
        product_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by product name (partial match)'
        })),
        product_Sku: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by product sku (exact match)'
        })),
        product_Uuid: z.optional(z.uuid().register(z.globalRegistry, {
            description: 'Filter by product UUID'
        })),
        quantity: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        quantity_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        quantity_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid()),
        withDiscounts: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ]))
    })),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zListCartItemResponse = zPaginatedCartItemList;

export const zCreateCartItemData = z.object({
    body: zCartItemCreateRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zCreateCartItemResponse = zCartItemDetail;

export const zDestroyCartItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

/**
 * No response body
 */
export const zDestroyCartItemResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveCartItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    })),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zRetrieveCartItemResponse = zCartItemDetail;

export const zPartialUpdateCartItemData = z.object({
    body: z.optional(zPatchedCartItemUpdateRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    })),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zPartialUpdateCartItemResponse = zCartItemDetail;

export const zUpdateCartItemData = z.object({
    body: z.optional(zCartItemUpdateRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zUpdateCartItemResponse = zCartItemDetail;

export const zListCartData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        cartType: z.optional(z.enum([
            'anonymous',
            'guest',
            'user'
        ]).register(z.globalRegistry, {
            description: 'Filter by cart type\n\n* `user` - User Cart\n* `guest` - Guest Cart\n* `anonymous` - Anonymous Cart'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        daysInactive: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        hasDiscounts: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasItems: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isAbandoned: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isGuest: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        lastActivity: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter by exact last activity date'
        })),
        lastActivity_Date: z.optional(z.iso.date()),
        lastActivity_Gte: z.optional(z.iso.datetime({ offset: true })),
        lastActivity_Lte: z.optional(z.iso.datetime({ offset: true })),
        lastActivityAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter carts with last activity after this date'
        })),
        lastActivityBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter carts with last activity before this date'
        })),
        maxItems: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxTotalValue: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxUniqueItems: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minItems: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minTotalValue: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minUniqueItems: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'user',
            '-user',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'lastActivity',
            '-lastActivity'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, user, -user, createdAt, -createdAt, updatedAt, -updatedAt, lastActivity, -lastActivity'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        user_IsActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_Isnull: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        userEmail: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email (partial match)'
        })),
        userName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user full name (first or last name)'
        })),
        uuid: z.optional(z.uuid())
    })),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zListCartResponse = zPaginatedCartList;

export const zReleaseCartReservationsData = z.object({
    body: zReleaseReservationsRequestRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zReleaseCartReservationsResponse = zReleaseReservationsResponse;

export const zReserveCartStockData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Cart-Id': z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zReserveCartStockResponse = zReserveStockResponse;

export const zCreateContactData = z.object({
    body: zContactWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCreateContactResponse = zContactWrite;

export const zListCountryData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        alpha2: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact 2-letter country code'
        })),
        alpha2_Icontains: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by 2-letter country code (partial match)'
        })),
        alpha2_Iexact: z.optional(z.string()),
        alpha2_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.string())
        ])),
        alpha3: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact 3-letter country code'
        })),
        alpha3_Icontains: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by 3-letter country code (partial match)'
        })),
        alpha3_Iexact: z.optional(z.string()),
        alpha3_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.string())
        ])),
        continent: z.optional(z.enum([
            'AF',
            'AN',
            'AS',
            'EU',
            'NA',
            'OC',
            'SA'
        ]).register(z.globalRegistry, {
            description: 'Filter by continent (based on ISO codes)\n\n* `AF` - Africa\n* `AS` - Asia\n* `EU` - Europe\n* `NA` - North America\n* `OC` - Oceania\n* `SA` - South America\n* `AN` - Antarctica'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        hasAllData: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasFlagImage: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasIsoCc: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasName: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasPhoneCode: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isEu: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isoCc: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        isoCc_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        isoCc_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isoCc_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        isoCcMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        isoCcMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        multipleCodes: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple country codes (comma-separated, alpha-2 or alpha-3)'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country name (partial match)'
        })),
        name_Exact: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact country name'
        })),
        name_Startswith: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter countries with names starting with'
        })),
        ordering: z.optional(z.enum([
            'alpha2',
            '-alpha2',
            'alpha3',
            '-alpha3',
            'isoCc',
            '-isoCc',
            'phoneCode',
            '-phoneCode',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'translations_Name',
            '-translations_Name'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: alpha2, -alpha2, alpha3, -alpha3, isoCc, -isoCc, phoneCode, -phoneCode, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, translations_Name, -translations_Name'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        phoneCode: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        phoneCode_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        phoneCode_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        phoneCode_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        phoneCodeMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        phoneCodeMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListCountryResponse = zPaginatedCountryList;

export const zCreateCountryData = z.object({
    body: zCountryWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateCountryResponse = zCountryDetail;

export const zDestroyCountryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        alpha2: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Country.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyCountryResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveCountryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        alpha2: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Country.'
        })
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveCountryResponse = zCountryDetail;

export const zPartialUpdateCountryData = z.object({
    body: z.optional(zPatchedCountryWriteRequest),
    path: z.object({
        alpha2: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Country.'
        })
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateCountryResponse = zCountryDetail;

export const zUpdateCountryData = z.object({
    body: zCountryWriteRequest,
    path: z.object({
        alpha2: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Country.'
        })
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateCountryResponse = zCountryDetail;

export const zHealthRetrieveData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zHealthRetrieveResponse = zHealthCheckResponse;

export const zGetNotificationsByIdsData = z.object({
    body: zNotificationIdsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        seen: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ]))
    }))
});

export const zGetNotificationsByIdsResponse = z.array(zNotification);

export const zListNotificationUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        hasSeenAt: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        highPriority: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        notification: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        notification_Category: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notification category'
        })),
        notification_ExpiresAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter notifications expiring after this date'
        })),
        notification_ExpiresBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter notifications expiring before this date'
        })),
        notification_IsExpired: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        notification_Kind: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notification kind'
        })),
        notification_Link: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notification link (case-insensitive)'
        })),
        notification_Message: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notification message (case-insensitive)'
        })),
        notification_Priority: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notification priority'
        })),
        notification_Title: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notification title (case-insensitive)'
        })),
        notification_Type: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notification type (case-insensitive)'
        })),
        notificationIds: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple notification IDs (comma-separated)'
        })),
        notificationKind: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notification kind'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'user',
            '-user',
            'user_Email',
            '-user_Email',
            'user_FirstName',
            '-user_FirstName',
            'user_LastName',
            '-user_LastName',
            'notification',
            '-notification',
            'notification_Kind',
            '-notification_Kind',
            'notification_Category',
            '-notification_Category',
            'notification_Priority',
            '-notification_Priority',
            'notification_CreatedAt',
            '-notification_CreatedAt',
            'seen',
            '-seen',
            'seenAt',
            '-seenAt',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, user, -user, user_Email, -user_Email, user_FirstName, -user_FirstName, user_LastName, -user_LastName, notification, -notification, notification_Kind, -notification_Kind, notification_Category, -notification_Category, notification_Priority, -notification_Priority, notification_CreatedAt, -notification_CreatedAt, seen, -seen, seenAt, -seenAt, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        recentNotifications: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        seen: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        seenAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter notifications seen after this date'
        })),
        seenAt_Date: z.optional(z.iso.date()),
        seenAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        seenAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        seenBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter notifications seen before this date'
        })),
        seenOnly: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        unseenOnly: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        user_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email (case-insensitive)'
        })),
        user_FirstName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user first name (case-insensitive)'
        })),
        user_IsActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_IsStaff: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_LastName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user last name (case-insensitive)'
        })),
        userIds: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple user IDs (comma-separated)'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListNotificationUserResponse = zPaginatedNotificationUserList;

export const zCreateNotificationUserData = z.object({
    body: zNotificationUserWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateNotificationUserResponse = zNotificationUserDetail;

export const zDestroyNotificationUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyNotificationUserResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveNotificationUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveNotificationUserResponse = zNotificationUserDetail;

export const zPartialUpdateNotificationUserData = z.object({
    body: z.optional(zPatchedNotificationUserWriteRequest),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateNotificationUserResponse = zNotificationUserDetail;

export const zUpdateNotificationUserData = z.object({
    body: zNotificationUserWriteRequest,
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateNotificationUserResponse = zNotificationUserDetail;

export const zMarkAllNotificationUsersAsSeenData = z.object({
    body: z.optional(zNotificationSuccessResponseRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zMarkAllNotificationUsersAsSeenResponse = zNotificationSuccessResponse;

export const zMarkAllNotificationUsersAsUnseenData = z.object({
    body: z.optional(zNotificationSuccessResponseRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zMarkAllNotificationUsersAsUnseenResponse = zNotificationSuccessResponse;

export const zMarkNotificationUsersAsSeenData = z.object({
    body: zNotificationUserActionRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zMarkNotificationUsersAsSeenResponse = zNotificationSuccessResponse;

export const zMarkNotificationUsersAsUnseenData = z.object({
    body: zNotificationUserActionRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zMarkNotificationUsersAsUnseenResponse = zNotificationSuccessResponse;

export const zGetNotificationUserUnseenCountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetNotificationUserUnseenCountResponse = zNotificationCountResponse;

export const zListOrderData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        activeOrders: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        canBeCanceled: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        city: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by city (case-insensitive)'
        })),
        city_Icontains: z.optional(z.string()),
        country: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country code'
        })),
        country_Alpha2: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country alpha-2 code'
        })),
        country_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country name (case-insensitive)'
        })),
        countryIds: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple country IDs (comma-separated)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        customerNotes: z.optional(z.string()),
        customerNotes_Icontains: z.optional(z.string()),
        documentType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by document type'
        })),
        email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by customer email (case-insensitive)'
        })),
        email_Icontains: z.optional(z.string()),
        finalOrders: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        firstName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by customer first name (case-insensitive)'
        })),
        firstName_Icontains: z.optional(z.string()),
        floor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by floor'
        })),
        hasCustomerNotes: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasPaymentId: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasStatusUpdatedAt: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasTracking: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasUser: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isCanceled: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isCompleted: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isPaid: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        lastName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by customer last name (case-insensitive)'
        })),
        lastName_Icontains: z.optional(z.string()),
        locationType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by location type'
        })),
        needsProcessing: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'status',
            '-status',
            'statusUpdatedAt',
            '-statusUpdatedAt',
            'paidAmount',
            '-paidAmount',
            'shippingPrice',
            '-shippingPrice',
            'paymentStatus',
            '-paymentStatus',
            'user_FirstName',
            '-user_FirstName',
            'user_LastName',
            '-user_LastName'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, status, -status, statusUpdatedAt, -statusUpdatedAt, paidAmount, -paidAmount, shippingPrice, -shippingPrice, paymentStatus, -paymentStatus, user_FirstName, -user_FirstName, user_LastName, -user_LastName'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        paidAmount_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        paidAmount_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        paidAmountMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        paidAmountMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        payWay: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        payWay_IsOnlinePayment: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        payWay_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by payment method name (case-insensitive)'
        })),
        paymentId: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by payment ID'
        })),
        paymentId_Icontains: z.optional(z.string()),
        paymentMethod: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by payment method'
        })),
        paymentMethod_Icontains: z.optional(z.string()),
        paymentStatus: z.optional(z.enum([
            'CANCELED',
            'COMPLETED',
            'FAILED',
            'PARTIALLY_REFUNDED',
            'PENDING',
            'PROCESSING',
            'REFUNDED'
        ]).register(z.globalRegistry, {
            description: 'Filter by payment status\n\n* `PENDING` - Pending\n* `PROCESSING` - Processing\n* `COMPLETED` - Completed\n* `FAILED` - Failed\n* `REFUNDED` - Refunded\n* `PARTIALLY_REFUNDED` - Partially Refunded\n* `CANCELED` - Canceled'
        })),
        paymentStatus_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.string())
        ])),
        phone: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by phone number'
        })),
        phone_Icontains: z.optional(z.string()),
        place: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by place (case-insensitive)'
        })),
        place_Icontains: z.optional(z.string()),
        recentOrders: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        region: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region code'
        })),
        region_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region name (case-insensitive)'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        shippingCarrier: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by shipping carrier'
        })),
        shippingCarrier_Icontains: z.optional(z.string()),
        shippingPrice_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        shippingPrice_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        shippingPriceMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        shippingPriceMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        status: z.optional(z.enum([
            'CANCELED',
            'COMPLETED',
            'DELIVERED',
            'PENDING',
            'PROCESSING',
            'REFUNDED',
            'RETURNED',
            'SHIPPED'
        ]).register(z.globalRegistry, {
            description: 'Filter by order status\n\n* `PENDING` - Pending\n* `PROCESSING` - Processing\n* `SHIPPED` - Shipped\n* `DELIVERED` - Delivered\n* `COMPLETED` - Completed\n* `CANCELED` - Canceled\n* `RETURNED` - Returned\n* `REFUNDED` - Refunded'
        })),
        status_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.string())
        ])),
        statusList: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple statuses (comma-separated)'
        })),
        statusUpdatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter orders with status updated after this date'
        })),
        statusUpdatedAt_Date: z.optional(z.iso.date()),
        statusUpdatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        statusUpdatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        statusUpdatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter orders with status updated before this date'
        })),
        street: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by street (case-insensitive)'
        })),
        street_Icontains: z.optional(z.string()),
        streetNumber: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by street number'
        })),
        streetNumber_Icontains: z.optional(z.string()),
        trackingNumber: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tracking number'
        })),
        trackingNumber_Icontains: z.optional(z.string()),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        user_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email (case-insensitive)'
        })),
        user_FirstName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user first name (case-insensitive)'
        })),
        user_IsActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_LastName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user last name (case-insensitive)'
        })),
        userIds: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple user IDs (comma-separated)'
        })),
        uuid: z.optional(z.uuid()),
        zipcode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by zipcode'
        }))
    }))
});

export const zListOrderResponse = zPaginatedOrderList;

export const zCreateOrderData = z.object({
    body: zOrderCreateFromCartRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateOrderResponse = zOrderDetail;

export const zListOrderItemData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        bulkItems: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        hasNotes: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasRefundedQuantity: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        highValueItems: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isFullyRefunded: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isPartiallyRefunded: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isRefunded: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        notes: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by notes content (case-insensitive)'
        })),
        notes_Icontains: z.optional(z.string()),
        order: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        order_Country: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by order country code'
        })),
        order_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by order customer email (case-insensitive)'
        })),
        order_FirstName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by order customer first name (case-insensitive)'
        })),
        order_LastName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by order customer last name (case-insensitive)'
        })),
        order_PaymentStatus: z.optional(z.enum([
            'CANCELED',
            'COMPLETED',
            'FAILED',
            'PARTIALLY_REFUNDED',
            'PENDING',
            'PROCESSING',
            'REFUNDED'
        ]).register(z.globalRegistry, {
            description: 'Filter by order payment status\n\n* `PENDING` - Pending\n* `PROCESSING` - Processing\n* `COMPLETED` - Completed\n* `FAILED` - Failed\n* `REFUNDED` - Refunded\n* `PARTIALLY_REFUNDED` - Partially Refunded\n* `CANCELED` - Canceled'
        })),
        order_Region: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by order region code'
        })),
        order_Status: z.optional(z.enum([
            'CANCELED',
            'COMPLETED',
            'DELIVERED',
            'PENDING',
            'PROCESSING',
            'REFUNDED',
            'RETURNED',
            'SHIPPED'
        ]).register(z.globalRegistry, {
            description: 'Filter by order status\n\n* `PENDING` - Pending\n* `PROCESSING` - Processing\n* `SHIPPED` - Shipped\n* `DELIVERED` - Delivered\n* `COMPLETED` - Completed\n* `CANCELED` - Canceled\n* `RETURNED` - Returned\n* `REFUNDED` - Refunded'
        })),
        order_User: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        order_User_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by order user email (case-insensitive)'
        })),
        orderIds: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple order IDs (comma-separated)'
        })),
        orderStatuses: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple order statuses (comma-separated)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'quantity',
            '-quantity',
            'price',
            '-price',
            'sortOrder',
            '-sortOrder'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, quantity, -quantity, price, -price, sortOrder, -sortOrder'
        })),
        originalQuantity: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        originalQuantity_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        originalQuantity_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        originalQuantityMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        originalQuantityMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        price: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        price_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        price_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        priceExact: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        priceMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        priceMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        product: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        product_Active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        product_Category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        product_Category_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by product category name (case-insensitive)'
        })),
        product_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by product name (case-insensitive)'
        })),
        product_Sku: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by product SKU'
        })),
        productIds: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple product IDs (comma-separated)'
        })),
        quantity: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        quantity_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        quantity_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        quantityExact: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        quantityMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        quantityMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        recentItems: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        refundedQuantity: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        refundedQuantity_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        refundedQuantity_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        refundedQuantityMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        refundedQuantityMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListOrderItemResponse = zPaginatedOrderItemList;

export const zCreateOrderItemData = z.object({
    body: zOrderItemWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateOrderItemResponse = zOrderItemDetail;

export const zDestroyOrderItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyOrderItemResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveOrderItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveOrderItemResponse = zOrderItemDetail;

export const zPartialUpdateOrderItemData = z.object({
    body: z.optional(zPatchedOrderItemWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateOrderItemResponse = zOrderItemDetail;

export const zUpdateOrderItemData = z.object({
    body: zOrderItemWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateOrderItemResponse = zOrderItemDetail;

export const zRefundOrderItemData = z.object({
    body: z.optional(zOrderItemRefundRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zRefundOrderItemResponse = zOrderItemRefundResponse;

export const zDestroyOrderData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyOrderResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveOrderData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveOrderResponse = zOrderDetail;

export const zPartialUpdateOrderData = z.object({
    body: z.optional(zPatchedOrderWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateOrderResponse = zOrderDetail;

export const zUpdateOrderData = z.object({
    body: zOrderWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateOrderResponse = zOrderDetail;

export const zAddOrderTrackingData = z.object({
    body: zAddTrackingRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zAddOrderTrackingResponse = zOrderDetail;

export const zCancelOrderData = z.object({
    body: z.optional(zCancelOrderRequestRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zCancelOrderResponse = zOrderDetail;

export const zCreateOrderCheckoutSessionData = z.object({
    body: zCreateCheckoutSessionRequestRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zCreateOrderCheckoutSessionResponse = zCreateCheckoutSessionResponse;

export const zCreateOrderPaymentIntentData = z.object({
    body: z.optional(zCreatePaymentIntentRequestRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zCreateOrderPaymentIntentResponse = zCreatePaymentIntentResponse;

export const zUpdateOrderStatusData = z.object({
    body: zUpdateStatusRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zUpdateOrderStatusResponse = zOrderDetail;

export const zListMyOrdersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        activeOrders: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        canBeCanceled: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        city: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by city (case-insensitive)'
        })),
        city_Icontains: z.optional(z.string()),
        country: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country code'
        })),
        country_Alpha2: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country alpha-2 code'
        })),
        country_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country name (case-insensitive)'
        })),
        countryIds: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple country IDs (comma-separated)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        customerNotes: z.optional(z.string()),
        customerNotes_Icontains: z.optional(z.string()),
        documentType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by document type'
        })),
        email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by customer email (case-insensitive)'
        })),
        email_Icontains: z.optional(z.string()),
        finalOrders: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        firstName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by customer first name (case-insensitive)'
        })),
        firstName_Icontains: z.optional(z.string()),
        floor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by floor'
        })),
        hasCustomerNotes: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasPaymentId: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasStatusUpdatedAt: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasTracking: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasUser: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isCanceled: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isCompleted: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isPaid: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        lastName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by customer last name (case-insensitive)'
        })),
        lastName_Icontains: z.optional(z.string()),
        locationType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by location type'
        })),
        needsProcessing: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'status',
            '-status',
            'statusUpdatedAt',
            '-statusUpdatedAt',
            'paidAmount',
            '-paidAmount',
            'shippingPrice',
            '-shippingPrice',
            'paymentStatus',
            '-paymentStatus',
            'user_FirstName',
            '-user_FirstName',
            'user_LastName',
            '-user_LastName'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, status, -status, statusUpdatedAt, -statusUpdatedAt, paidAmount, -paidAmount, shippingPrice, -shippingPrice, paymentStatus, -paymentStatus, user_FirstName, -user_FirstName, user_LastName, -user_LastName'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        paidAmount_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        paidAmount_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        paidAmountMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        paidAmountMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        payWay: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        payWay_IsOnlinePayment: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        payWay_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by payment method name (case-insensitive)'
        })),
        paymentId: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by payment ID'
        })),
        paymentId_Icontains: z.optional(z.string()),
        paymentMethod: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by payment method'
        })),
        paymentMethod_Icontains: z.optional(z.string()),
        paymentStatus: z.optional(z.enum([
            'CANCELED',
            'COMPLETED',
            'FAILED',
            'PARTIALLY_REFUNDED',
            'PENDING',
            'PROCESSING',
            'REFUNDED'
        ]).register(z.globalRegistry, {
            description: 'Filter by payment status\n\n* `PENDING` - Pending\n* `PROCESSING` - Processing\n* `COMPLETED` - Completed\n* `FAILED` - Failed\n* `REFUNDED` - Refunded\n* `PARTIALLY_REFUNDED` - Partially Refunded\n* `CANCELED` - Canceled'
        })),
        paymentStatus_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.string())
        ])),
        phone: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by phone number'
        })),
        phone_Icontains: z.optional(z.string()),
        place: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by place (case-insensitive)'
        })),
        place_Icontains: z.optional(z.string()),
        recentOrders: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        region: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region code'
        })),
        region_Name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region name (case-insensitive)'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        shippingCarrier: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by shipping carrier'
        })),
        shippingCarrier_Icontains: z.optional(z.string()),
        shippingPrice_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        shippingPrice_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        shippingPriceMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        shippingPriceMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        status: z.optional(z.enum([
            'CANCELED',
            'COMPLETED',
            'DELIVERED',
            'PENDING',
            'PROCESSING',
            'REFUNDED',
            'RETURNED',
            'SHIPPED'
        ]).register(z.globalRegistry, {
            description: 'Filter by order status\n\n* `PENDING` - Pending\n* `PROCESSING` - Processing\n* `SHIPPED` - Shipped\n* `DELIVERED` - Delivered\n* `COMPLETED` - Completed\n* `CANCELED` - Canceled\n* `RETURNED` - Returned\n* `REFUNDED` - Refunded'
        })),
        status_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.string())
        ])),
        statusList: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple statuses (comma-separated)'
        })),
        statusUpdatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter orders with status updated after this date'
        })),
        statusUpdatedAt_Date: z.optional(z.iso.date()),
        statusUpdatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        statusUpdatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        statusUpdatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter orders with status updated before this date'
        })),
        street: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by street (case-insensitive)'
        })),
        street_Icontains: z.optional(z.string()),
        streetNumber: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by street number'
        })),
        streetNumber_Icontains: z.optional(z.string()),
        trackingNumber: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tracking number'
        })),
        trackingNumber_Icontains: z.optional(z.string()),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        user_Email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email (case-insensitive)'
        })),
        user_FirstName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user first name (case-insensitive)'
        })),
        user_IsActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        user_LastName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user last name (case-insensitive)'
        })),
        userIds: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by multiple user IDs (comma-separated)'
        })),
        uuid: z.optional(z.uuid()),
        zipcode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by zipcode'
        }))
    }))
});

export const zListMyOrdersResponse = zPaginatedOrderList;

export const zRetrieveOrderByUuidData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        uuid: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zRetrieveOrderByUuidResponse = zOrderDetail;

export const zListPayWayData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        cost_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        cost_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        costMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        costMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        description: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by description (partial match)'
        })),
        freeThreshold_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        freeThreshold_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        freeThresholdMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        freeThresholdMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        hasConfiguration: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasIcon: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        isOnlinePayment: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by name (partial match)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'cost',
            '-cost',
            'freeThreshold',
            '-freeThreshold',
            'providerCode',
            '-providerCode',
            'isOnlinePayment',
            '-isOnlinePayment',
            'requiresConfirmation',
            '-requiresConfirmation',
            'sortOrder',
            '-sortOrder'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, cost, -cost, freeThreshold, -freeThreshold, providerCode, -providerCode, isOnlinePayment, -isOnlinePayment, requiresConfirmation, -requiresConfirmation, sortOrder, -sortOrder'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        providerCode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by provider code (partial match)'
        })),
        providerCode_Icontains: z.optional(z.string()),
        requiresConfirmation: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        uuid: z.optional(z.uuid())
    }))
});

export const zListPayWayResponse = zPaginatedPayWayList;

export const zCreatePayWayData = z.object({
    body: zPayWayWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreatePayWayResponse = zPayWayDetail;

export const zDestroyPayWayData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyPayWayResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrievePayWayData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrievePayWayResponse = zPayWayDetail;

export const zPartialUpdatePayWayData = z.object({
    body: z.optional(zPatchedPayWayWriteRequest),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdatePayWayResponse = zPayWayDetail;

export const zUpdatePayWayData = z.object({
    body: zPayWayWriteRequest,
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdatePayWayResponse = zPayWayDetail;

export const zListProductData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        attribute: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        attribute_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        attributeValue: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        attributeValue_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        category: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by category ID (supports multiple IDs separated by underscore)'
        })),
        categoryId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        deletedAt_Date: z.optional(z.iso.date()),
        deletedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        deletedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        discountPercent: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        discountPercent_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        discountPercent_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        hasDiscount: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        inStock: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isDeleted: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        maxDiscount: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxDiscountPercent: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxFinalPrice: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxPrice: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxReviewAverage: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        maxStock: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        maxViewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        maxWeight: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minDiscount: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minDiscountPercent: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minFinalPrice: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLikes: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minPrice: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minReviewAverage: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minStock: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        minViewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        minWeight: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        ordering: z.optional(z.enum([
            'price',
            '-price',
            'createdAt',
            '-createdAt',
            'active',
            '-active',
            'availabilityPriority',
            '-availabilityPriority',
            'viewCount',
            '-viewCount',
            'stock',
            '-stock'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: price, -price, createdAt, -createdAt, active, -active, availabilityPriority, -availabilityPriority, viewCount, -viewCount, stock, -stock'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        price: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        price_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        price_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sku: z.optional(z.string()),
        sku_Icontains: z.optional(z.string()),
        stock: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        stock_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        stock_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid()),
        viewCount: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        viewCount_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        weight: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        weight_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        weight_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ]))
    }))
});

export const zListProductResponse = zPaginatedProductList;

export const zCreateProductData = z.object({
    body: zProductWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateProductResponse = zProductDetail;

export const zDestroyProductData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyProductResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveProductData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveProductResponse = zProductDetail;

export const zPartialUpdateProductData = z.object({
    body: z.optional(zPatchedProductWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateProductResponse = zProductDetail;

export const zUpdateProductData = z.object({
    body: zProductWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateProductResponse = zProductDetail;

export const zListProductImagesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zListProductImagesResponse = z.array(zProductImage);

export const zListProductReviewsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        }))
    }))
});

export const zListProductReviewsResponse = z.object({
    links: z.optional(z.object({
        next: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        previous: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    })),
    count: z.optional(z.int()),
    total_pages: z.optional(z.int()),
    page_size: z.optional(z.int()),
    page_total_results: z.optional(z.int()),
    results: z.optional(z.array(zProductReview))
});

export const zListProductTagsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zListProductTagsResponse = z.array(zTag);

export const zIncrementProductViewsData = z.object({
    body: zProductDetailRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zIncrementProductViewsResponse = zProductDetail;

export const zListAttributeData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        hasValues: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        name: z.optional(z.string()),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'sortOrder',
            '-sortOrder',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, sortOrder, -sortOrder, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrderMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrderMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListAttributeResponse = zPaginatedAttributeList;

export const zCreateAttributeData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateAttributeResponse = zAttribute;

export const zDestroyAttributeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyAttributeResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveAttributeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveAttributeResponse = zAttribute;

export const zPartialUpdateAttributeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateAttributeResponse = zAttribute;

export const zUpdateAttributeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateAttributeResponse = zAttribute;

export const zListAttributeValueData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        attribute: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        attribute_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'attribute',
            '-attribute',
            'sortOrder',
            '-sortOrder',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, attribute, -attribute, sortOrder, -sortOrder, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrderMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrderMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid()),
        value: z.optional(z.string())
    }))
});

export const zListAttributeValueResponse = zPaginatedAttributeValueList;

export const zCreateAttributeValueData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateAttributeValueResponse = zAttributeValue;

export const zDestroyAttributeValueData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyAttributeValueResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveAttributeValueData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveAttributeValueResponse = zAttributeValue;

export const zPartialUpdateAttributeValueData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateAttributeValueResponse = zAttributeValue;

export const zUpdateAttributeValueData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateAttributeValueResponse = zAttributeValue;

export const zListProductCategoryData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        ancestorOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        descendantOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        hasChildren: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasProducts: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isLeaf: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isRoot: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        level: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        level_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        maxLevel: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        maxProductCount: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minLevel: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        minProductCount: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'sortOrder',
            '-sortOrder',
            'level',
            '-level',
            'lft',
            '-lft',
            'rght',
            '-rght',
            'treeId',
            '-treeId',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, sortOrder, -sortOrder, level, -level, lft, -lft, rght, -rght, treeId, -treeId, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        parent: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        parentSlug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by parent category slug'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        siblingOf: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        slug: z.optional(z.string()),
        slug_Icontains: z.optional(z.string()),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrderMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrderMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListProductCategoryResponse = zPaginatedProductCategoryList;

export const zCreateProductCategoryData = z.object({
    body: zProductCategoryWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateProductCategoryResponse = zProductCategoryDetail;

export const zDestroyProductCategoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyProductCategoryResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveProductCategoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveProductCategoryResponse = zProductCategoryDetail;

export const zPartialUpdateProductCategoryData = z.object({
    body: z.optional(zPatchedProductCategoryWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateProductCategoryResponse = zProductCategoryDetail;

export const zUpdateProductCategoryData = z.object({
    body: zProductCategoryWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateProductCategoryResponse = zProductCategoryDetail;

export const zListAllProductCategoryData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Array of all product categories
 */
export const zListAllProductCategoryResponse = z.array(zProductCategory).register(z.globalRegistry, {
    description: 'Array of all product categories'
});

export const zListProductCategoryImageData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        category: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        imageType: z.optional(z.enum([
            'BACKGROUND',
            'BANNER',
            'FEATURE',
            'GALLERY',
            'HERO',
            'ICON',
            'MAIN',
            'PROMOTIONAL',
            'SEASONAL',
            'THUMBNAIL'
        ]).register(z.globalRegistry, {
            description: '* `MAIN` - Main Image\n* `BANNER` - Banner Image\n* `ICON` - Icon Image\n* `THUMBNAIL` - Thumbnail Image\n* `GALLERY` - Gallery Image\n* `BACKGROUND` - Background Image\n* `HERO` - Hero Image\n* `FEATURE` - Feature Image\n* `PROMOTIONAL` - Promotional Image\n* `SEASONAL` - Seasonal Image'
        })),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        ordering: z.optional(z.enum([
            'createdAt',
            '-createdAt',
            'imageType',
            '-imageType',
            'sortOrder',
            '-sortOrder'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: createdAt, -createdAt, imageType, -imageType, sortOrder, -sortOrder'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListProductCategoryImageResponse = zPaginatedProductCategoryImageList;

export const zCreateProductCategoryImageData = z.object({
    body: zProductCategoryImageWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateProductCategoryImageResponse = zProductCategoryImageDetail;

export const zDestroyProductCategoryImageData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyProductCategoryImageResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveProductCategoryImageData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveProductCategoryImageResponse = zProductCategoryImageDetail;

export const zPartialUpdateProductCategoryImageData = z.object({
    body: z.optional(zPatchedProductCategoryImageWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateProductCategoryImageResponse = zProductCategoryImageDetail;

export const zUpdateProductCategoryImageData = z.object({
    body: zProductCategoryImageWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateProductCategoryImageResponse = zProductCategoryImageDetail;

export const zBulkUpdateProductCategoryImagesData = z.object({
    body: z.optional(zPatchedProductCategoryImageBulkUpdateRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zBulkUpdateProductCategoryImagesResponse = zProductCategoryImageBulkResponse;

export const zGetProductCategoryImagesByCategoryData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetProductCategoryImagesByCategoryResponse = z.array(zProductCategoryImage);

export const zGetProductCategoryImagesByTypeData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetProductCategoryImagesByTypeResponse = z.array(zProductCategoryImage);

export const zListProductFavouriteData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'userId',
            '-userId',
            'productId',
            '-productId',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, userId, -userId, productId, -productId, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        product: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        productId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        userId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        uuid: z.optional(z.uuid())
    }))
});

export const zListProductFavouriteResponse = zPaginatedProductFavouriteList;

export const zCreateProductFavouriteData = z.object({
    body: zProductFavouriteWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateProductFavouriteResponse = zProductFavouriteWrite;

export const zDestroyProductFavouriteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyProductFavouriteResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveProductFavouriteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveProductFavouriteResponse = zProductFavouriteDetail;

export const zPartialUpdateProductFavouriteData = z.object({
    body: z.optional(zPatchedProductFavouriteWriteRequest),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateProductFavouriteResponse = zProductFavouriteWrite;

export const zUpdateProductFavouriteData = z.object({
    body: zProductFavouriteWriteRequest,
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateProductFavouriteResponse = zProductFavouriteWrite;

export const zGetProductFavouriteProductData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zGetProductFavouriteProductResponse = zProductDetailResponse;

export const zGetProductFavouritesByProductsData = z.object({
    body: zProductFavouriteByProductsRequestRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetProductFavouritesByProductsResponse = z.array(z.object({
    id: z.int(),
    userId: z.int(),
    productId: z.int(),
    createdAt: z.iso.datetime({ offset: true })
}));

export const zListProductImageData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        createdAt: z.optional(z.iso.datetime({ offset: true })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        isMain: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'isMain',
            '-isMain',
            'sortOrder',
            '-sortOrder'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, isMain, -isMain, sortOrder, -sortOrder'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        product: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAt: z.optional(z.iso.datetime({ offset: true }))
    }))
});

export const zListProductImageResponse = zPaginatedProductImageList;

export const zCreateProductImageData = z.object({
    body: zProductImageWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateProductImageResponse = zProductImageDetail;

export const zDestroyProductImageData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyProductImageResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveProductImageData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveProductImageResponse = zProductImageDetail;

export const zPartialUpdateProductImageData = z.object({
    body: z.optional(zPatchedProductImageWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateProductImageResponse = zProductImageDetail;

export const zUpdateProductImageData = z.object({
    body: zProductImageWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateProductImageResponse = zProductImageDetail;

export const zListProductReviewData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        comment: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by comment content (partial match)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        currentlyPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        hasComment: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        helpfulVotesMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        isPublished: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        maxRate: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        minRate: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'userId',
            '-userId',
            'productId',
            '-productId',
            'rate',
            '-rate',
            'status',
            '-status',
            'isPublished',
            '-isPublished',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'publishedAt',
            '-publishedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, userId, -userId, productId, -productId, rate, -rate, status, -status, isPublished, -isPublished, createdAt, -createdAt, updatedAt, -updatedAt, publishedAt, -publishedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        product: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        productActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        productAvgRatingMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        productAvgRatingMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        productCategory: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        productId: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        productName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by product name (partial match)'
        })),
        publishedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published after this date'
        })),
        publishedAt_Date: z.optional(z.iso.date()),
        publishedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        publishedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        publishedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items published before this date'
        })),
        publishedRecentDays: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        rate: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rate_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rate_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rateMax: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        rateMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        recentDays: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        status: z.optional(z.enum([
            'FALSE',
            'NEW',
            'TRUE'
        ]).register(z.globalRegistry, {
            description: 'Filter by review status\n\n* `NEW` - New\n* `TRUE` - True\n* `FALSE` - False'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        user: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        userEmail: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user email (partial match)'
        })),
        userFirstName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user first name (partial match)'
        })),
        userId: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        userLastName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by user last name (partial match)'
        })),
        userReviewCountMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        uuid: z.optional(z.uuid()),
        verifiedPurchase: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ]))
    }))
});

export const zListProductReviewResponse = zPaginatedProductReviewList;

export const zCreateProductReviewData = z.object({
    body: zProductReviewWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateProductReviewResponse = zProductReviewDetail;

export const zDestroyProductReviewData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyProductReviewResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveProductReviewData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveProductReviewResponse = zProductReviewDetail;

export const zPartialUpdateProductReviewData = z.object({
    body: z.optional(zPatchedProductReviewWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateProductReviewResponse = zProductReviewDetail;

export const zUpdateProductReviewData = z.object({
    body: zProductReviewWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateProductReviewResponse = zProductReviewDetail;

export const zGetProductReviewProductData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zGetProductReviewProductResponse = zProduct;

export const zGetUserProductReviewData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zGetUserProductReviewResponse = zProductReviewDetail;

export const zListRegionData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        alpha: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region alpha code (partial match)'
        })),
        alpha_Icontains: z.optional(z.string()),
        alphaExact: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact region alpha code'
        })),
        country: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country alpha-2 code'
        })),
        countryName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country name (partial match)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region name (partial match)'
        })),
        ordering: z.optional(z.enum([
            'createdAt',
            '-createdAt',
            'alpha',
            '-alpha',
            'sortOrder',
            '-sortOrder'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: createdAt, -createdAt, alpha, -alpha, sortOrder, -sortOrder'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListRegionResponse = zPaginatedRegionList;

export const zCreateRegionData = z.object({
    body: zRegionWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateRegionResponse = zRegionDetail;

export const zDestroyRegionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        alpha: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Region.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyRegionResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveRegionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        alpha: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Region.'
        })
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveRegionResponse = zRegionDetail;

export const zPartialUpdateRegionData = z.object({
    body: z.optional(zPatchedRegionWriteRequest),
    path: z.object({
        alpha: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Region.'
        })
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateRegionResponse = zRegionDetail;

export const zUpdateRegionData = z.object({
    body: zRegionWriteRequest,
    path: z.object({
        alpha: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Region.'
        })
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateRegionResponse = zRegionDetail;

export const zListRegionsByCountryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        alpha: z.string().register(z.globalRegistry, {
            description: 'A unique value identifying this Region.'
        })
    }),
    query: z.optional(z.object({
        alpha: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region alpha code (partial match)'
        })),
        alpha_Icontains: z.optional(z.string()),
        alphaExact: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact region alpha code'
        })),
        country: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country alpha-2 code'
        })),
        countryName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country name (partial match)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region name (partial match)'
        })),
        ordering: z.optional(z.enum([
            'createdAt',
            '-createdAt',
            'alpha',
            '-alpha',
            'sortOrder',
            '-sortOrder'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: createdAt, -createdAt, alpha, -alpha, sortOrder, -sortOrder'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListRegionsByCountryResponse = zPaginatedRegionList;

export const zSearchAnalyticsRetrieveData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        contentType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by content type: \'product\', \'blog_post\', or \'federated\'. If not provided, includes all content types.'
        })),
        endDate: z.optional(z.string().register(z.globalRegistry, {
            description: 'End date for analytics range (ISO format: YYYY-MM-DD). If not provided, includes data up to current date.'
        })),
        startDate: z.optional(z.string().register(z.globalRegistry, {
            description: 'Start date for analytics range (ISO format: YYYY-MM-DD). If not provided, includes all historical data.'
        }))
    }))
});

export const zSearchAnalyticsRetrieveResponse = zSearchAnalyticsResponse;

export const zSearchBlogPostRetrieveData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        languageCode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Language code to filter results (e.g., \'en\', \'el\', \'de\'). If not provided, searches all languages.'
        })),
        limit: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        offset: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        query: z.string().register(z.globalRegistry, {
            description: 'Search query string'
        })
    })
});

export const zSearchBlogPostRetrieveResponse = zBlogPostMeiliSearchResponse;

export const zSearchFederatedRetrieveData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        languageCode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Language code to filter results (e.g., \'en\', \'el\', \'de\'). If not provided, searches all languages.'
        })),
        limit: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        offset: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        query: z.string().register(z.globalRegistry, {
            description: 'Search query string'
        })
    })
});

export const zSearchFederatedRetrieveResponse = zFederatedSearchResponse;

export const zSearchProductRetrieveData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        categories: z.optional(z.string().register(z.globalRegistry, {
            description: 'Comma-separated category IDs (category IN [ids])'
        })),
        facets: z.optional(z.string().register(z.globalRegistry, {
            description: 'Comma-separated facet fields for counts and stats'
        })),
        languageCode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Language code to filter results (e.g., \'en\', \'el\', \'de\'). If not provided, searches all languages.'
        })),
        likesMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        limit: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        offset: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        priceMax: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        priceMin: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        query: z.optional(z.string().register(z.globalRegistry, {
            description: 'Full-text search query (empty for no search filter)'
        })),
        sort: z.optional(z.string().register(z.globalRegistry, {
            description: 'Sort field (finalPrice, -finalPrice, -likesCount, -viewCount, -createdAt)'
        })),
        viewsMin: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ]))
    }))
});

export const zSearchProductRetrieveResponse = zProductMeiliSearchResponse;

export const zSettingsListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zSettingsListResponse = z.array(zSetting);

export const zSettingsGetRetrieveData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        key: z.string().register(z.globalRegistry, {
            description: 'Setting key name (e.g., CHECKOUT_SHIPPING_PRICE)'
        })
    })
});

export const zSettingsGetRetrieveResponse = zSettingDetail;

export const zListTagData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        contentType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter tags used for specific content type'
        })),
        contentType_AppLabel: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter tags used for content from specific app'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        hasLabel: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        hasUsage: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        label: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tag label (partial match)'
        })),
        label_Exact: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact tag label'
        })),
        label_Startswith: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter tags with labels starting with'
        })),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        maxUsageCount: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        minUsageCount: z.optional(z.union([
            z.string().regex(/^-?\d+(\.\d+)?$/),
            z.number()
        ])),
        mostUsed: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        objectId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'active',
            '-active',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'sortOrder',
            '-sortOrder',
            'translations_Label',
            '-translations_Label'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, active, -active, createdAt, -createdAt, updatedAt, -updatedAt, sortOrder, -sortOrder, translations_Label, -translations_Label'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        sortOrder: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Gte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        sortOrder_Lte: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        translations_Label: z.optional(z.string()),
        translations_Label_Icontains: z.optional(z.string()),
        translations_Label_Istartswith: z.optional(z.string()),
        unused: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListTagResponse = zPaginatedTagList;

export const zCreateTagData = z.object({
    body: zTagWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateTagResponse = zTagDetail;

export const zDestroyTagData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyTagResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveTagData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveTagResponse = zTagDetail;

export const zPartialUpdateTagData = z.object({
    body: z.optional(zPatchedTagWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateTagResponse = zTagDetail;

export const zUpdateTagData = z.object({
    body: zTagWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateTagResponse = zTagDetail;

export const zListTaggedItemData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        contentType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by content type model name'
        })),
        contentType_AppLabel: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by content type app label'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        objectId: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        objectId_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int().gte(0).lte(2147483647))
        ])),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'objectId',
            '-objectId',
            'tag_Translations_Label',
            '-tag_Translations_Label'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, objectId, -objectId, tag_Translations_Label, -tag_Translations_Label'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        tag: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        tag_Active: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        tag_Label: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by tag label (partial match)'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListTaggedItemResponse = zPaginatedTaggedItemList;

export const zCreateTaggedItemData = z.object({
    body: zTaggedItemWriteRequestWritable,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateTaggedItemResponse = zTaggedItemDetail;

export const zDestroyTaggedItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyTaggedItemResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveTaggedItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveTaggedItemResponse = zTaggedItemDetail;

export const zPartialUpdateTaggedItemData = z.object({
    body: z.optional(zPatchedTaggedItemWriteRequestWritable),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateTaggedItemResponse = zTaggedItemDetail;

export const zUpdateTaggedItemData = z.object({
    body: zTaggedItemWriteRequestWritable,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateTaggedItemResponse = zTaggedItemDetail;

export const zListUserAccountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'email',
            '-email',
            'username',
            '-username',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, email, -email, username, -username, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zListUserAccountResponse = zPaginatedUserDetailsList;

export const zCreateUserAccountData = z.object({
    body: zUserWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateUserAccountResponse = zUserDetails;

export const zDestroyUserAccountData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyUserAccountResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveUserAccountData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveUserAccountResponse = zUserDetails;

export const zPartialUpdateUserAccountData = z.object({
    body: z.optional(zPatchedUserWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateUserAccountResponse = zUserDetails;

export const zUpdateUserAccountData = z.object({
    body: zUserWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateUserAccountResponse = zUserDetails;

export const zGetUserAccountAddressesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'email',
            '-email',
            'username',
            '-username',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, email, -email, username, -username, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetUserAccountAddressesResponse = zPaginatedUserAddressList;

export const zGetUserAccountBlogPostCommentsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'email',
            '-email',
            'username',
            '-username',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, email, -email, username, -username, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetUserAccountBlogPostCommentsResponse = zPaginatedBlogCommentList;

export const zChangeUserAccountUsernameData = z.object({
    body: zUsernameUpdateRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zChangeUserAccountUsernameResponse = zUsernameUpdateResponse;

export const zGetUserAccountFavouriteProductsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'email',
            '-email',
            'username',
            '-username',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, email, -email, username, -username, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetUserAccountFavouriteProductsResponse = zPaginatedProductFavouriteList;

export const zGetUserAccountLikedBlogPostsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'email',
            '-email',
            'username',
            '-username',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, email, -email, username, -username, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetUserAccountLikedBlogPostsResponse = zPaginatedBlogPostList;

export const zGetUserAccountNotificationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'email',
            '-email',
            'username',
            '-username',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, email, -email, username, -username, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetUserAccountNotificationsResponse = zPaginatedNotificationUserList;

export const zGetUserAccountOrdersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'email',
            '-email',
            'username',
            '-username',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, email, -email, username, -username, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetUserAccountOrdersResponse = zPaginatedOrderList;

export const zGetUserAccountProductReviewsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'email',
            '-email',
            'username',
            '-username',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, email, -email, username, -username, createdAt, -createdAt, updatedAt, -updatedAt'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        }))
    }))
});

export const zGetUserAccountProductReviewsResponse = zPaginatedProductReviewList;

export const zListUserAddressData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        city: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by city name (partial match)'
        })),
        city_Icontains: z.optional(z.string()),
        country: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country alpha_2 code'
        })),
        countryCode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country code (e.g., \'US\', \'CA\')'
        })),
        countryName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by country name (partial match)'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        firstName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by first name (partial match)'
        })),
        firstName_Icontains: z.optional(z.string()),
        floor: z.optional(z.enum([
            '',
            'BASEMENT',
            'FIFTH_FLOOR',
            'FIRST_FLOOR',
            'FOURTH_FLOOR',
            'GROUND_FLOOR',
            'SECOND_FLOOR',
            'SIXTH_FLOOR_PLUS',
            'THIRD_FLOOR'
        ]).register(z.globalRegistry, {
            description: 'Filter by floor'
        })),
        fullName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by full name (first + last name)'
        })),
        hasNotes: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isMain: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        lastName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by last name (partial match)'
        })),
        lastName_Icontains: z.optional(z.string()),
        locationType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by location type (exact match, case insensitive)'
        })),
        locationType_Icontains: z.optional(z.string()),
        locationTypeContains: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by location type (partial match)'
        })),
        ordering: z.optional(z.enum([
            'id',
            '-id',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'city',
            '-city',
            'zipcode',
            '-zipcode',
            'isMain',
            '-isMain'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: id, -id, createdAt, -createdAt, updatedAt, -updatedAt, city, -city, zipcode, -zipcode, isMain, -isMain'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        phone: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by phone number (partial match)'
        })),
        phone_Icontains: z.optional(z.string()),
        region: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region alpha code'
        })),
        regionCode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region code'
        })),
        regionName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by region name (partial match)'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        street: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by street name (partial match)'
        })),
        street_Icontains: z.optional(z.string()),
        streetNumber: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by street number'
        })),
        streetNumber_Icontains: z.optional(z.string()),
        title: z.optional(z.string()),
        title_Icontains: z.optional(z.string()),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid()),
        zipcode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by zipcode (partial match)'
        })),
        zipcode_Icontains: z.optional(z.string()),
        zipcodeExact: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact zipcode'
        }))
    }))
});

export const zListUserAddressResponse = zPaginatedUserAddressList;

export const zCreateUserAddressData = z.object({
    body: zUserAddressWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateUserAddressResponse = zUserAddressDetail;

export const zDestroyUserAddressData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyUserAddressResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveUserAddressData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveUserAddressResponse = zUserAddressDetail;

export const zPartialUpdateUserAddressData = z.object({
    body: z.optional(zPatchedUserAddressWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateUserAddressResponse = zUserAddressDetail;

export const zUpdateUserAddressData = z.object({
    body: zUserAddressWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateUserAddressResponse = zUserAddressDetail;

export const zSetMainUserAddressData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zSetMainUserAddressResponse = zUserAddressDetail;

export const zListUserSubscriptionData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        hasMetadata: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isConfirmed: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        ordering: z.optional(z.enum([
            'subscribedAt',
            '-subscribedAt',
            'unsubscribedAt',
            '-unsubscribedAt',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'status',
            '-status',
            'topic_Category',
            '-topic_Category'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: subscribedAt, -subscribedAt, unsubscribedAt, -unsubscribedAt, createdAt, -createdAt, updatedAt, -updatedAt, status, -status, topic_Category, -topic_Category'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        status: z.optional(z.enum([
            'ACTIVE',
            'BOUNCED',
            'PENDING',
            'UNSUBSCRIBED'
        ]).register(z.globalRegistry, {
            description: 'Filter by subscription status\n\n* `ACTIVE` - Active\n* `PENDING` - Pending Confirmation\n* `UNSUBSCRIBED` - Unsubscribed\n* `BOUNCED` - Bounced'
        })),
        subscribedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter subscriptions created after this date'
        })),
        subscribedAt_Date: z.optional(z.iso.date()),
        subscribedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        subscribedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        subscribedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter subscriptions created before this date'
        })),
        topic: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        topicCategory: z.optional(z.enum([
            'ACCOUNT',
            'MARKETING',
            'NEWSLETTER',
            'OTHER',
            'PRODUCT',
            'PROMOTIONAL',
            'SYSTEM'
        ]).register(z.globalRegistry, {
            description: 'Filter by topic category\n\n* `MARKETING` - Marketing Campaigns\n* `PRODUCT` - Product Updates\n* `ACCOUNT` - Λογαριασμός Ανενεργός\n* `SYSTEM` - System Notifications\n* `NEWSLETTER` - Newsletter\n* `PROMOTIONAL` - Promotional\n* `OTHER` - Other'
        })),
        topicDescription: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by topic description (partial match)'
        })),
        topicName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by topic name (partial match)'
        })),
        topicSlug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by topic slug (partial match)'
        })),
        topicSlugExact: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact topic slug'
        })),
        unsubscribedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter subscriptions unsubscribed after this date'
        })),
        unsubscribedAt_Date: z.optional(z.iso.date()),
        unsubscribedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        unsubscribedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        unsubscribedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter subscriptions unsubscribed before this date'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListUserSubscriptionResponse = zPaginatedUserSubscriptionList;

export const zCreateUserSubscriptionData = z.object({
    body: zUserSubscriptionWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateUserSubscriptionResponse = zUserSubscriptionDetail;

export const zDestroyUserSubscriptionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroyUserSubscriptionResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveUserSubscriptionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveUserSubscriptionResponse = zUserSubscriptionDetail;

export const zPartialUpdateUserSubscriptionData = z.object({
    body: z.optional(zPatchedUserSubscriptionWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateUserSubscriptionResponse = zUserSubscriptionDetail;

export const zUpdateUserSubscriptionData = z.object({
    body: zUserSubscriptionWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateUserSubscriptionResponse = zUserSubscriptionDetail;

export const zConfirmUserSubscriptionData = z.object({
    body: zUserSubscriptionDetailRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zConfirmUserSubscriptionResponse = zUserSubscriptionDetail;

export const zBulkUpdateUserSubscriptionsData = z.object({
    body: zBulkSubscriptionRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zListSubscriptionTopicData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        category: z.optional(z.enum([
            'ACCOUNT',
            'MARKETING',
            'NEWSLETTER',
            'OTHER',
            'PRODUCT',
            'PROMOTIONAL',
            'SYSTEM'
        ]).register(z.globalRegistry, {
            description: 'Filter by topic category\n\n* `MARKETING` - Marketing Campaigns\n* `PRODUCT` - Product Updates\n* `ACCOUNT` - Λογαριασμός Ανενεργός\n* `SYSTEM` - System Notifications\n* `NEWSLETTER` - Newsletter\n* `PROMOTIONAL` - Promotional\n* `OTHER` - Other'
        })),
        createdAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created after this date'
        })),
        createdAt_Date: z.optional(z.iso.date()),
        createdAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        createdAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        createdBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items created before this date'
        })),
        cursor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Cursor for pagination'
        })),
        description: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by description (partial match)'
        })),
        hasSubscribers: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        id: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        id_In: z.optional(z.union([
            z.string().register(z.globalRegistry, {
                description: 'Comma-separated values'
            }),
            z.array(z.int())
        ])),
        isActive: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        isDefault: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by name (partial match)'
        })),
        ordering: z.optional(z.enum([
            'category',
            '-category',
            'createdAt',
            '-createdAt',
            'updatedAt',
            '-updatedAt',
            'slug',
            '-slug'
        ]).register(z.globalRegistry, {
            description: 'Which field to use when ordering the results. Available fields: category, -category, createdAt, -createdAt, updatedAt, -updatedAt, slug, -slug'
        })),
        page: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pageSize: z.optional(z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])),
        pagination: z.optional(z.enum(['false', 'true']).register(z.globalRegistry, {
            description: 'Enable or disable pagination'
        })),
        paginationType: z.optional(z.enum([
            'cursor',
            'limitOffset',
            'pageNumber'
        ]).register(z.globalRegistry, {
            description: 'Pagination strategy type'
        })),
        requiresConfirmation: z.optional(z.union([
            z.literal('true'),
            z.literal('false'),
            z.literal('1'),
            z.literal('0'),
            z.boolean()
        ])),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'A search term.'
        })),
        slug: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by slug (partial match)'
        })),
        slug_Icontains: z.optional(z.string()),
        slugExact: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filter by exact slug'
        })),
        updatedAfter: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated after this date'
        })),
        updatedAt_Date: z.optional(z.iso.date()),
        updatedAt_Gte: z.optional(z.iso.datetime({ offset: true })),
        updatedAt_Lte: z.optional(z.iso.datetime({ offset: true })),
        updatedBefore: z.optional(z.iso.datetime({ offset: true }).register(z.globalRegistry, {
            description: 'Filter items updated before this date'
        })),
        uuid: z.optional(z.uuid())
    }))
});

export const zListSubscriptionTopicResponse = zPaginatedSubscriptionTopicList;

export const zCreateSubscriptionTopicData = z.object({
    body: zSubscriptionTopicWriteRequest,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zCreateSubscriptionTopicResponse = zSubscriptionTopicDetail;

export const zDestroySubscriptionTopicData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * No response body
 */
export const zDestroySubscriptionTopicResponse = z.void().register(z.globalRegistry, {
    description: 'No response body'
});

export const zRetrieveSubscriptionTopicData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zRetrieveSubscriptionTopicResponse = zSubscriptionTopicDetail;

export const zPartialUpdateSubscriptionTopicData = z.object({
    body: z.optional(zPatchedSubscriptionTopicWriteRequest),
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zPartialUpdateSubscriptionTopicResponse = zSubscriptionTopicDetail;

export const zUpdateSubscriptionTopicData = z.object({
    body: zSubscriptionTopicWriteRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.object({
        languageCode: z.optional(z.enum([
            'de',
            'el',
            'en'
        ]).register(z.globalRegistry, {
            description: 'Language code for translations (el, en, de)'
        }))
    }))
});

export const zUpdateSubscriptionTopicResponse = zSubscriptionTopicDetail;

export const zSubscribeToTopicData = z.object({
    body: zUserSubscriptionRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zSubscribeToTopicResponse = zUserSubscription;

export const zUnsubscribeFromTopicData = z.object({
    body: zDetailRequest,
    path: z.object({
        id: z.union([
            z.string().regex(/^-?\d+$/),
            z.int()
        ])
    }),
    query: z.optional(z.never())
});

export const zGetMySubscriptionTopicsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetMySubscriptionTopicsResponse = z.object({
    subscribed: z.optional(z.array(zSubscriptionTopic)),
    available: z.optional(z.array(zSubscriptionTopic))
});

export const zUnsubscribeViaLinkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        token: z.string(),
        topicSlug: z.string(),
        uidb64: z.string()
    }),
    query: z.optional(z.never())
});

export const zUnsubscribeViaLinkResponse = zUnsubscribe;
